module gbi;

/**************************************************************************
 *									  *
 *		 Copyright (C) 1994, Silicon Graphics, Inc.		  *
 *									  *
 *  These coded instructions, statements, and computer programs  contain  *
 *  unpublished  proprietary  information of Silicon Graphics, Inc., and  *
 *  are protected by Federal copyright law.  They  may  not be disclosed  *
 *  to  third  parties  or copied or duplicated in any form, in whole or  *
 *  in part, without the prior written consent of Silicon Graphics, Inc.  *
 *									  *
 **************************************************************************/
/**************************************************************************
 *
 *  $Revision: 1.141 $
 *  $Date: 1999/09/03 03:43:08 $
 *  $Source: /exdisk2/cvs/N64OS/Master/cvsmdev2/PR/include/gbi.h,v $
 *
 **************************************************************************/

extern (C):

/*
 * To use the F3DEX ucodes, define F3DEX_GBI before include this file.
 *
 *     #define  F3DEX_GBI
 *     #include <ultra64.h>
 *
 *     or
 *
 *     cc -c -DF3DEX_GBI -I.... foo.c
 *
 */

/**************************************************************************
 *
 * Graphics Binary Interface
 *
 **************************************************************************/

/*
 * Graphics Commands, 'xxx' parts may be generated from ucode
 *
 * The command format is
 *
 *	|00xxxxxx| = DMA		0,..,127
 *	|10xxxxxx| = Immediate Mode	-65,..,-128
 *	|11xxxxxx| = RDP cmds		-1,..,-64
 *
 * Note: in order for the RSP microcode to process RDP commands opaquely,
 * we need to further identify those RDP commands that need DRAM address
 * "fixup". To do this, we have the dummy command G_RDP_ADDR_FIXUP, and
 * all |RDP commands| less than this are commands with embedded DRAM
 * addresses. Further, the format of these commands should be similar so
 * only one fixup routine is needed.
 *
 * Further explanation:
 * The names of the commands are somewhat misleading. Here is clarification:
 *
 *	- a 'DMA' type command has a pointer to additional data and
 *	  causes a DMA transfer to bring that into DMEM.
 *
 *	- an 'Immediate' type command isn't really 'immediate', in the
 *	  traditional sense. This just means that the entire command fits
 *	  in the 64-bit word, and the ucode can execute it 'immediately'
 *	  without additional memory transfers.
 *
 *	- an 'RDP' command is identified as such because the RDP
 *	  commands can be passed-thru the RSP and sent to the RDP
 *	  directly. One further confusing thing, is that some 'DP'
 *	  macros below actually generate immediate commands, not
 *	  not direct DP commands.
 *
 * IMPLEMENTATION NOTE:
 * There is another group of RDP commands that includes the triangle commands
 * generated by the RSP code. These are the raw commands the rasterizer
 * hardware chews on, with slope info, etc. They will follow the RDP
 * ordering...
 *
 * IMPLEMENTATION NOTE:
 * The RDP hardware has some of these bit patterns wired up. If the hardware
 * changes, we must adjust this table, likewise we can't change/add things
 * once the hardware is frozen. (actually, the RDP hardware only looks at
 * the lower 6 bits of the command byte)
 *
 */

/* F3DEX_GBI_2 */

/* DMA commands: */
enum G_SPNOOP = 0; /* handle 0 gracefully */
enum G_MTX = 1;
enum G_RESERVED0 = 2; /* not implemeted */
enum G_MOVEMEM = 3; /* move a block of memory (up to 4 words) to dmem */
enum G_VTX = 4;
enum G_RESERVED1 = 5; /* not implemeted */
enum G_DL = 6;
enum G_RESERVED2 = 7; /* not implemeted */
enum G_RESERVED3 = 8; /* not implemeted */
enum G_SPRITE2D_BASE = 9; /* sprite command */

/* IMMEDIATE commands: */
enum G_IMMFIRST = -65;
enum G_TRI1 = G_IMMFIRST - 0;
enum G_CULLDL = G_IMMFIRST - 1;
enum G_POPMTX = G_IMMFIRST - 2;
enum G_MOVEWORD = G_IMMFIRST - 3;
enum G_TEXTURE = G_IMMFIRST - 4;
enum G_SETOTHERMODE_H = G_IMMFIRST - 5;
enum G_SETOTHERMODE_L = G_IMMFIRST - 6;
enum G_ENDDL = G_IMMFIRST - 7;
enum G_SETGEOMETRYMODE = G_IMMFIRST - 8;
enum G_CLEARGEOMETRYMODE = G_IMMFIRST - 9;
enum G_LINE3D = G_IMMFIRST - 10;
enum G_RDPHALF_1 = G_IMMFIRST - 11;
enum G_RDPHALF_2 = G_IMMFIRST - 12;

enum G_RDPHALF_CONT = G_IMMFIRST - 13;

/* We are overloading 2 of the immediate commands
   to keep the byte alignment of dmem the same */

enum G_SPRITE2D_SCALEFLIP = G_IMMFIRST - 1;
enum G_SPRITE2D_DRAW = G_IMMFIRST - 2;

/* RDP commands: */
enum G_NOOP = 0xc0; /*   0 */

/* F3DEX_GBI_2 */

/* RDP commands: */
enum G_SETCIMG = 0xff; /*  -1 */
enum G_SETZIMG = 0xfe; /*  -2 */
enum G_SETTIMG = 0xfd; /*  -3 */
enum G_SETCOMBINE = 0xfc; /*  -4 */
enum G_SETENVCOLOR = 0xfb; /*  -5 */
enum G_SETPRIMCOLOR = 0xfa; /*  -6 */
enum G_SETBLENDCOLOR = 0xf9; /*  -7 */
enum G_SETFOGCOLOR = 0xf8; /*  -8 */
enum G_SETFILLCOLOR = 0xf7; /*  -9 */
enum G_FILLRECT = 0xf6; /* -10 */
enum G_SETTILE = 0xf5; /* -11 */
enum G_LOADTILE = 0xf4; /* -12 */
enum G_LOADBLOCK = 0xf3; /* -13 */
enum G_SETTILESIZE = 0xf2; /* -14 */
enum G_LOADTLUT = 0xf0; /* -16 */
enum G_RDPSETOTHERMODE = 0xef; /* -17 */
enum G_SETPRIMDEPTH = 0xee; /* -18 */
enum G_SETSCISSOR = 0xed; /* -19 */
enum G_SETCONVERT = 0xec; /* -20 */
enum G_SETKEYR = 0xeb; /* -21 */
enum G_SETKEYGB = 0xea; /* -22 */
enum G_RDPFULLSYNC = 0xe9; /* -23 */
enum G_RDPTILESYNC = 0xe8; /* -24 */
enum G_RDPPIPESYNC = 0xe7; /* -25 */
enum G_RDPLOADSYNC = 0xe6; /* -26 */
enum G_TEXRECTFLIP = 0xe5; /* -27 */
enum G_TEXRECT = 0xe4; /* -28 */

/*
 * The following commands are the "generated" RDP commands; the user
 * never sees them, the RSP microcode generates them.
 *
 * The layout of the bits is magical, to save work in the ucode.
 * These id's are -56, -52, -54, -50, -55, -51, -53, -49, ...
 *                                 edge, shade, texture, zbuff bits:  estz
 */
enum G_TRI_FILL = 0xc8; /* fill triangle:            11001000 */
enum G_TRI_SHADE = 0xcc; /* shade triangle:           11001100 */
enum G_TRI_TXTR = 0xca; /* texture triangle:         11001010 */
enum G_TRI_SHADE_TXTR = 0xce; /* shade, texture triangle:  11001110 */
enum G_TRI_FILL_ZBUFF = 0xc9; /* fill, zbuff triangle:     11001001 */
enum G_TRI_SHADE_ZBUFF = 0xcd; /* shade, zbuff triangle:    11001101 */
enum G_TRI_TXTR_ZBUFF = 0xcb; /* texture, zbuff triangle:  11001011 */
enum G_TRI_SHADE_TXTR_ZBUFF = 0xcf; /* shade, txtr, zbuff trngl: 11001111 */

/*
 * A TRI_FILL triangle is just the edges. You need to set the DP
 * to use primcolor, in order to see anything. (it is NOT a triangle
 * that gets rendered in 'fill mode'. Triangles can't be rendered
 * in 'fill mode')
 *
 * A TRI_SHADE is a gouraud triangle that has colors interpolated.
 * Flat-shaded triangles (from the software) are still gouraud shaded,
 * it's just the colors are all the same and the deltas are 0.
 *
 * Other triangle types, and combinations are more obvious.
 */

/* masks to build RDP triangle commands: */
enum G_RDP_TRI_FILL_MASK = 0x08;
enum G_RDP_TRI_SHADE_MASK = 0x04;
enum G_RDP_TRI_TXTR_MASK = 0x02;
enum G_RDP_TRI_ZBUFF_MASK = 0x01;

/*
 * HACK:
 * This is a dreadful hack. For version 1.0 hardware, there are still
 * some 'bowtie' hangs. This parameter can be increased to avoid
 * the hangs. Every increase of 4 chops one scanline off of every
 * triangle. Values of 4,8,12 should be sufficient to avoid any
 * bowtie hang.
 *
 * Change this value, then recompile ALL of your program (including static
 * display lists!)
 *
 * THIS WILL BE REMOVED FOR HARDWARE VERSION 2.0!
 */
enum BOWTIE_VAL = 0;

/* gets added to RDP command, in order to test for addres fixup: */
enum G_RDP_ADDR_FIXUP = 3; /* |RDP cmds| <= this, do addr fixup */

/* macros for command parsing: */
extern (D) auto GDMACMD(T)(auto ref T x)
{
    return x;
}

extern (D) auto GIMMCMD(T)(auto ref T x)
{
    return G_IMMFIRST - x;
}

extern (D) auto GRDPCMD(T)(auto ref T x)
{
    return 0xff - x;
}

enum G_DMACMDSIZ = 128;
enum G_IMMCMDSIZ = 64;
enum G_RDPCMDSIZ = 64;

/*
 * Coordinate shift values, number of bits of fraction
 */
enum G_TEXTURE_IMAGE_FRAC = 2;
enum G_TEXTURE_SCALE_FRAC = 16;
enum G_SCALE_FRAC = 8;
enum G_ROTATE_FRAC = 16;

/*
 * Parameters to graphics commands
 */

/*
 * Data packing macros
 */

/*
 * Maximum z-buffer value, used to initialize the z-buffer.
 * Note : this number is NOT the viewport z-scale constant.
 * See the comment next to G_MAXZ for more info.
 */
enum G_MAXFBZ = 0x3fff; /* 3b exp, 11b mantissa */

extern (D) auto GPACK_RGBA5551(T0, T1, T2, T3)(auto ref T0 r, auto ref T1 g, auto ref T2 b, auto ref T3 a)
{
    return ((r << 8) & 0xf800) | ((g << 3) & 0x7c0) | ((b >> 2) & 0x3e) | (a & 0x1);
}

extern (D) auto GPACK_ZDZ(T0, T1)(auto ref T0 z, auto ref T1 dz)
{
    return z << 2 | dz;
}

/*
 * G_MTX: parameter flags
 */

/* matrix types */

/* concat or load */

/* push or not */

/* F3DEX_GBI_2 */
enum G_MTX_MODELVIEW = 0x00; /* matrix types */
enum G_MTX_PROJECTION = 0x01;
enum G_MTX_MUL = 0x00; /* concat or load */
enum G_MTX_LOAD = 0x02;
enum G_MTX_NOPUSH = 0x00; /* push or not */
enum G_MTX_PUSH = 0x04;
/* F3DEX_GBI_2 */

/*
 * flags for G_SETGEOMETRYMODE
 * (this rendering state is maintained in RSP)
 *
 * DO NOT USE THE LOW 8 BITS OF GEOMETRYMODE:
 * The weird bit-ordering is for the micro-code: the lower byte
 * can be OR'd in with G_TRI_SHADE (11001100) to construct
 * the triangle command directly. Don't break it...
 *
 * DO NOT USE THE HIGH 8 BITS OF GEOMETRYMODE:
 * The high byte is OR'd with 0x703 to form the clip code mask.
 * If it is set to 0x04, this will cause near clipping to occur.
 * If it is zero, near clipping will not occur.
 *
 * Further explanation:
 * G_SHADE is necessary in order to see the color that you passed
 * down with the vertex. If G_SHADE isn't set, you need to set the DP
 * appropriately and use primcolor to see anything.
 *
 * G_SHADING_SMOOTH enabled means use all 3 colors of the triangle.
 * If it is not set, then do 'flat shading', where only one vertex color
 * is used (and all 3 vertices are set to that same color by the ucode)
 * See the man page for gSP1Triangle().
 *
 */
enum G_ZBUFFER = 0x00000001;
enum G_SHADE = 0x00000004; /* enable Gouraud interp */
/* rest of low byte reserved for setup ucode */

/* Ignored               */
/* flat or smooth shaded */

/* To make code cleaner */

enum G_TEXTURE_ENABLE = 0x00000002; /* Microcode use only */
enum G_SHADING_SMOOTH = 0x00000200; /* flat or smooth shaded */
enum G_CULL_FRONT = 0x00001000;
enum G_CULL_BACK = 0x00002000;
enum G_CULL_BOTH = 0x00003000; /* To make code cleaner */

enum G_FOG = 0x00010000;
enum G_LIGHTING = 0x00020000;
enum G_TEXTURE_GEN = 0x00040000;
enum G_TEXTURE_GEN_LINEAR = 0x00080000;
enum G_LOD = 0x00100000; /* NOT IMPLEMENTED */

enum G_CLIPPING = 0x00000000;

/* NOT IMPLEMENTED */

/* Need these defined for Sprite Microcode */

/*
 * G_SETIMG fmt: set image formats
 */
enum G_IM_FMT_RGBA = 0;
enum G_IM_FMT_YUV = 1;
enum G_IM_FMT_CI = 2;
enum G_IM_FMT_IA = 3;
enum G_IM_FMT_I = 4;

/*
 * G_SETIMG siz: set image pixel size
 */
enum G_IM_SIZ_4b = 0;
enum G_IM_SIZ_8b = 1;
enum G_IM_SIZ_16b = 2;
enum G_IM_SIZ_32b = 3;
enum G_IM_SIZ_DD = 5;

enum G_IM_SIZ_4b_BYTES = 0;
enum G_IM_SIZ_4b_TILE_BYTES = G_IM_SIZ_4b_BYTES;
enum G_IM_SIZ_4b_LINE_BYTES = G_IM_SIZ_4b_BYTES;

enum G_IM_SIZ_8b_BYTES = 1;
enum G_IM_SIZ_8b_TILE_BYTES = G_IM_SIZ_8b_BYTES;
enum G_IM_SIZ_8b_LINE_BYTES = G_IM_SIZ_8b_BYTES;

enum G_IM_SIZ_16b_BYTES = 2;
enum G_IM_SIZ_16b_TILE_BYTES = G_IM_SIZ_16b_BYTES;
enum G_IM_SIZ_16b_LINE_BYTES = G_IM_SIZ_16b_BYTES;

enum G_IM_SIZ_32b_BYTES = 4;
enum G_IM_SIZ_32b_TILE_BYTES = 2;
enum G_IM_SIZ_32b_LINE_BYTES = 2;

enum G_IM_SIZ_4b_LOAD_BLOCK = G_IM_SIZ_16b;
enum G_IM_SIZ_8b_LOAD_BLOCK = G_IM_SIZ_16b;
enum G_IM_SIZ_16b_LOAD_BLOCK = G_IM_SIZ_16b;
enum G_IM_SIZ_32b_LOAD_BLOCK = G_IM_SIZ_32b;

enum G_IM_SIZ_4b_SHIFT = 2;
enum G_IM_SIZ_8b_SHIFT = 1;
enum G_IM_SIZ_16b_SHIFT = 0;
enum G_IM_SIZ_32b_SHIFT = 0;

enum G_IM_SIZ_4b_INCR = 3;
enum G_IM_SIZ_8b_INCR = 1;
enum G_IM_SIZ_16b_INCR = 0;
enum G_IM_SIZ_32b_INCR = 0;

/*
 * G_SETCOMBINE: color combine modes
 */
/* Color combiner constants: */
enum G_CCMUX_COMBINED = 0;
enum G_CCMUX_TEXEL0 = 1;
enum G_CCMUX_TEXEL1 = 2;
enum G_CCMUX_PRIMITIVE = 3;
enum G_CCMUX_SHADE = 4;
enum G_CCMUX_ENVIRONMENT = 5;
enum G_CCMUX_CENTER = 6;
enum G_CCMUX_SCALE = 6;
enum G_CCMUX_COMBINED_ALPHA = 7;
enum G_CCMUX_TEXEL0_ALPHA = 8;
enum G_CCMUX_TEXEL1_ALPHA = 9;
enum G_CCMUX_PRIMITIVE_ALPHA = 10;
enum G_CCMUX_SHADE_ALPHA = 11;
enum G_CCMUX_ENV_ALPHA = 12;
enum G_CCMUX_LOD_FRACTION = 13;
enum G_CCMUX_PRIM_LOD_FRAC = 14;
enum G_CCMUX_NOISE = 7;
enum G_CCMUX_K4 = 7;
enum G_CCMUX_K5 = 15;
enum G_CCMUX_1 = 6;
enum G_CCMUX_0 = 31;

/* Alpha combiner constants: */
enum G_ACMUX_COMBINED = 0;
enum G_ACMUX_TEXEL0 = 1;
enum G_ACMUX_TEXEL1 = 2;
enum G_ACMUX_PRIMITIVE = 3;
enum G_ACMUX_SHADE = 4;
enum G_ACMUX_ENVIRONMENT = 5;
enum G_ACMUX_LOD_FRACTION = 0;
enum G_ACMUX_PRIM_LOD_FRAC = 6;
enum G_ACMUX_1 = 6;
enum G_ACMUX_0 = 7;

/* typical CC cycle 1 modes */

//enum G_CC_MODULATERGB = G_CC_MODULATEI;
//enum G_CC_MODULATERGBDECALA = G_CC_MODULATEIDECALA;
//enum G_CC_MODULATERGBFADE = G_CC_MODULATEIFADE;

//enum G_CC_MODULATERGBA = G_CC_MODULATEIA;
//enum G_CC_MODULATERGBFADEA = G_CC_MODULATEIFADEA;

//enum G_CC_MODULATERGB_PRIM = G_CC_MODULATEI_PRIM;
//enum G_CC_MODULATERGBA_PRIM = G_CC_MODULATEIA_PRIM;
//enum G_CC_MODULATERGBDECALA_PRIM = G_CC_MODULATEIDECALA_PRIM;

/* oddball modes */
/* used for 1-cycle sparse mip-maps, primitive color has color of lowest LOD */

/* typical CC cycle 1 modes, usually followed by other cycle 2 modes */

/*
 *  One-cycle color convert operation
 */

/*
 *  NOTE: YUV2RGB expects TF step1 color conversion to occur in 2nd clock.
 * Therefore, CC looks for step1 results in TEXEL1
 */

/* typical CC cycle 2 modes */
//enum G_CC_MODULATERGB2 = G_CC_MODULATEI2;
//enum G_CC_MODULATERGBA2 = G_CC_MODULATEIA2;
//enum G_CC_MODULATERGB_PRIM2 = G_CC_MODULATEI_PRIM2;
//enum G_CC_MODULATERGBA_PRIM2 = G_CC_MODULATEIA_PRIM2;
/*
 * ?
#define	G_CC_DECALRGBA2		COMBINED, SHADE, COMBINED_ALPHA, SHADE, 0, 0, 0, SHADE
*/

/*
 * G_SETOTHERMODE_L sft: shift count
 */
enum G_MDSFT_ALPHACOMPARE = 0;
enum G_MDSFT_ZSRCSEL = 2;
enum G_MDSFT_RENDERMODE = 3;
enum G_MDSFT_BLENDER = 16;

/*
 * G_SETOTHERMODE_H sft: shift count
 */
enum G_MDSFT_BLENDMASK = 0; /* unsupported */
enum G_MDSFT_ALPHADITHER = 4;
enum G_MDSFT_RGBDITHER = 6;

enum G_MDSFT_COMBKEY = 8;
enum G_MDSFT_TEXTCONV = 9;
enum G_MDSFT_TEXTFILT = 12;
enum G_MDSFT_TEXTLUT = 14;
enum G_MDSFT_TEXTLOD = 16;
enum G_MDSFT_TEXTDETAIL = 17;
enum G_MDSFT_TEXTPERSP = 19;
enum G_MDSFT_CYCLETYPE = 20;
enum G_MDSFT_COLORDITHER = 22; /* unsupported in HW 2.0 */
enum G_MDSFT_PIPELINE = 23;

/* G_SETOTHERMODE_H gPipelineMode */
enum G_PM_1PRIMITIVE = 1 << G_MDSFT_PIPELINE;
enum G_PM_NPRIMITIVE = 0 << G_MDSFT_PIPELINE;

/* G_SETOTHERMODE_H gSetCycleType */
enum G_CYC_1CYCLE = 0 << G_MDSFT_CYCLETYPE;
enum G_CYC_2CYCLE = 1 << G_MDSFT_CYCLETYPE;
enum G_CYC_COPY = 2 << G_MDSFT_CYCLETYPE;
enum G_CYC_FILL = 3 << G_MDSFT_CYCLETYPE;

/* G_SETOTHERMODE_H gSetTexturePersp */
enum G_TP_NONE = 0 << G_MDSFT_TEXTPERSP;
enum G_TP_PERSP = 1 << G_MDSFT_TEXTPERSP;

/* G_SETOTHERMODE_H gSetTextureDetail */
enum G_TD_CLAMP = 0 << G_MDSFT_TEXTDETAIL;
enum G_TD_SHARPEN = 1 << G_MDSFT_TEXTDETAIL;
enum G_TD_DETAIL = 2 << G_MDSFT_TEXTDETAIL;

/* G_SETOTHERMODE_H gSetTextureLOD */
enum G_TL_TILE = 0 << G_MDSFT_TEXTLOD;
enum G_TL_LOD = 1 << G_MDSFT_TEXTLOD;

/* G_SETOTHERMODE_H gSetTextureLUT */
enum G_TT_NONE = 0 << G_MDSFT_TEXTLUT;
enum G_TT_RGBA16 = 2 << G_MDSFT_TEXTLUT;
enum G_TT_IA16 = 3 << G_MDSFT_TEXTLUT;

/* G_SETOTHERMODE_H gSetTextureFilter */
enum G_TF_POINT = 0 << G_MDSFT_TEXTFILT;
enum G_TF_AVERAGE = 3 << G_MDSFT_TEXTFILT;
enum G_TF_BILERP = 2 << G_MDSFT_TEXTFILT;

/* G_SETOTHERMODE_H gSetTextureConvert */
enum G_TC_CONV = 0 << G_MDSFT_TEXTCONV;
enum G_TC_FILTCONV = 5 << G_MDSFT_TEXTCONV;
enum G_TC_FILT = 6 << G_MDSFT_TEXTCONV;

/* G_SETOTHERMODE_H gSetCombineKey */
enum G_CK_NONE = 0 << G_MDSFT_COMBKEY;
enum G_CK_KEY = 1 << G_MDSFT_COMBKEY;

/* G_SETOTHERMODE_H gSetColorDither */
enum G_CD_MAGICSQ = 0 << G_MDSFT_RGBDITHER;
enum G_CD_BAYER = 1 << G_MDSFT_RGBDITHER;
enum G_CD_NOISE = 2 << G_MDSFT_RGBDITHER;

enum G_CD_DISABLE = 3 << G_MDSFT_RGBDITHER;
enum G_CD_ENABLE = G_CD_NOISE; /* HW 1.0 compatibility mode */

/* G_SETOTHERMODE_H gSetAlphaDither */
enum G_AD_PATTERN = 0 << G_MDSFT_ALPHADITHER;
enum G_AD_NOTPATTERN = 1 << G_MDSFT_ALPHADITHER;
enum G_AD_NOISE = 2 << G_MDSFT_ALPHADITHER;
enum G_AD_DISABLE = 3 << G_MDSFT_ALPHADITHER;

/* G_SETOTHERMODE_L gSetAlphaCompare */
enum G_AC_NONE = 0 << G_MDSFT_ALPHACOMPARE;
enum G_AC_THRESHOLD = 1 << G_MDSFT_ALPHACOMPARE;
enum G_AC_DITHER = 3 << G_MDSFT_ALPHACOMPARE;

/* G_SETOTHERMODE_L gSetDepthSource */
enum G_ZS_PIXEL = 0 << G_MDSFT_ZSRCSEL;
enum G_ZS_PRIM = 1 << G_MDSFT_ZSRCSEL;

/* G_SETOTHERMODE_L gSetRenderMode */
enum AA_EN = 0x8;
enum Z_CMP = 0x10;
enum Z_UPD = 0x20;
enum IM_RD = 0x40;
enum CLR_ON_CVG = 0x80;
enum CVG_DST_CLAMP = 0;
enum CVG_DST_WRAP = 0x100;
enum CVG_DST_FULL = 0x200;
enum CVG_DST_SAVE = 0x300;
enum ZMODE_OPA = 0;
enum ZMODE_INTER = 0x400;
enum ZMODE_XLU = 0x800;
enum ZMODE_DEC = 0xc00;
enum CVG_X_ALPHA = 0x1000;
enum ALPHA_CVG_SEL = 0x2000;
enum FORCE_BL = 0x4000;
enum TEX_EDGE = 0x0000; /* used to be 0x8000 */

enum G_BL_CLR_IN = 0;
enum G_BL_CLR_MEM = 1;
enum G_BL_CLR_BL = 2;
enum G_BL_CLR_FOG = 3;
enum G_BL_1MA = 0;
enum G_BL_A_MEM = 1;
enum G_BL_A_IN = 0;
enum G_BL_A_FOG = 1;
enum G_BL_A_SHADE = 2;
enum G_BL_1 = 2;
enum G_BL_0 = 3;

extern (D) auto GBL_c1(T0, T1, T2, T3)(auto ref T0 m1a, auto ref T1 m1b, auto ref T2 m2a, auto ref T3 m2b)
{
    return m1a << 30 | m1b << 26 | m2a << 22 | m2b << 18;
}

extern (D) auto GBL_c2(T0, T1, T2, T3)(auto ref T0 m1a, auto ref T1 m1b, auto ref T2 m2a, auto ref T3 m2b)
{
    return m1a << 28 | m1b << 24 | m2a << 20 | m2b << 16;
}

/* for rendering to an 8-bit framebuffer */

/* Custom version of RM_AA_ZB_XLU_SURF with Z_UPD */
//extern (D) auto RM_CUSTOM_AA_ZB_XLU_SURF(T)(auto ref T clk)
//{
//    return RM_AA_ZB_XLU_SURF(clk) | Z_UPD;
//}

//enum G_RM_AA_ZB_OPA_SURF = RM_AA_ZB_OPA_SURF(1);
//enum G_RM_AA_ZB_OPA_SURF2 = RM_AA_ZB_OPA_SURF(2);
//enum G_RM_AA_ZB_XLU_SURF = RM_AA_ZB_XLU_SURF(1);
//enum G_RM_AA_ZB_XLU_SURF2 = RM_AA_ZB_XLU_SURF(2);
//enum G_RM_AA_ZB_OPA_DECAL = RM_AA_ZB_OPA_DECAL(1);
//enum G_RM_AA_ZB_OPA_DECAL2 = RM_AA_ZB_OPA_DECAL(2);
//enum G_RM_AA_ZB_XLU_DECAL = RM_AA_ZB_XLU_DECAL(1);
//enum G_RM_AA_ZB_XLU_DECAL2 = RM_AA_ZB_XLU_DECAL(2);
//enum G_RM_AA_ZB_OPA_INTER = RM_AA_ZB_OPA_INTER(1);
//enum G_RM_AA_ZB_OPA_INTER2 = RM_AA_ZB_OPA_INTER(2);
//enum G_RM_AA_ZB_XLU_INTER = RM_AA_ZB_XLU_INTER(1);
//enum G_RM_AA_ZB_XLU_INTER2 = RM_AA_ZB_XLU_INTER(2);
//enum G_RM_AA_ZB_XLU_LINE = RM_AA_ZB_XLU_LINE(1);
//enum G_RM_AA_ZB_XLU_LINE2 = RM_AA_ZB_XLU_LINE(2);
//enum G_RM_AA_ZB_DEC_LINE = RM_AA_ZB_DEC_LINE(1);
//enum G_RM_AA_ZB_DEC_LINE2 = RM_AA_ZB_DEC_LINE(2);
//enum G_RM_AA_ZB_TEX_EDGE = RM_AA_ZB_TEX_EDGE(1);
//enum G_RM_AA_ZB_TEX_EDGE2 = RM_AA_ZB_TEX_EDGE(2);
//enum G_RM_AA_ZB_TEX_INTER = RM_AA_ZB_TEX_INTER(1);
//enum G_RM_AA_ZB_TEX_INTER2 = RM_AA_ZB_TEX_INTER(2);
//enum G_RM_AA_ZB_SUB_SURF = RM_AA_ZB_SUB_SURF(1);
//enum G_RM_AA_ZB_SUB_SURF2 = RM_AA_ZB_SUB_SURF(2);
//enum G_RM_AA_ZB_PCL_SURF = RM_AA_ZB_PCL_SURF(1);
//enum G_RM_AA_ZB_PCL_SURF2 = RM_AA_ZB_PCL_SURF(2);
//enum G_RM_AA_ZB_OPA_TERR = RM_AA_ZB_OPA_TERR(1);
//enum G_RM_AA_ZB_OPA_TERR2 = RM_AA_ZB_OPA_TERR(2);
//enum G_RM_AA_ZB_TEX_TERR = RM_AA_ZB_TEX_TERR(1);
//enum G_RM_AA_ZB_TEX_TERR2 = RM_AA_ZB_TEX_TERR(2);
//enum G_RM_AA_ZB_SUB_TERR = RM_AA_ZB_SUB_TERR(1);
//enum G_RM_AA_ZB_SUB_TERR2 = RM_AA_ZB_SUB_TERR(2);

//enum G_RM_RA_ZB_OPA_SURF = RM_RA_ZB_OPA_SURF(1);
//enum G_RM_RA_ZB_OPA_SURF2 = RM_RA_ZB_OPA_SURF(2);
//enum G_RM_RA_ZB_OPA_DECAL = RM_RA_ZB_OPA_DECAL(1);
//enum G_RM_RA_ZB_OPA_DECAL2 = RM_RA_ZB_OPA_DECAL(2);
//enum G_RM_RA_ZB_OPA_INTER = RM_RA_ZB_OPA_INTER(1);
//enum G_RM_RA_ZB_OPA_INTER2 = RM_RA_ZB_OPA_INTER(2);

//enum G_RM_AA_OPA_SURF = RM_AA_OPA_SURF(1);
//enum G_RM_AA_OPA_SURF2 = RM_AA_OPA_SURF(2);
//enum G_RM_AA_XLU_SURF = RM_AA_XLU_SURF(1);
//enum G_RM_AA_XLU_SURF2 = RM_AA_XLU_SURF(2);
//enum G_RM_AA_XLU_LINE = RM_AA_XLU_LINE(1);
//enum G_RM_AA_XLU_LINE2 = RM_AA_XLU_LINE(2);
//enum G_RM_AA_DEC_LINE = RM_AA_DEC_LINE(1);
//enum G_RM_AA_DEC_LINE2 = RM_AA_DEC_LINE(2);
//enum G_RM_AA_TEX_EDGE = RM_AA_TEX_EDGE(1);
//enum G_RM_AA_TEX_EDGE2 = RM_AA_TEX_EDGE(2);
//enum G_RM_AA_SUB_SURF = RM_AA_SUB_SURF(1);
//enum G_RM_AA_SUB_SURF2 = RM_AA_SUB_SURF(2);
//enum G_RM_AA_PCL_SURF = RM_AA_PCL_SURF(1);
//enum G_RM_AA_PCL_SURF2 = RM_AA_PCL_SURF(2);
//enum G_RM_AA_OPA_TERR = RM_AA_OPA_TERR(1);
//enum G_RM_AA_OPA_TERR2 = RM_AA_OPA_TERR(2);
//enum G_RM_AA_TEX_TERR = RM_AA_TEX_TERR(1);
//enum G_RM_AA_TEX_TERR2 = RM_AA_TEX_TERR(2);
//enum G_RM_AA_SUB_TERR = RM_AA_SUB_TERR(1);
//enum G_RM_AA_SUB_TERR2 = RM_AA_SUB_TERR(2);

//enum G_RM_RA_OPA_SURF = RM_RA_OPA_SURF(1);
//enum G_RM_RA_OPA_SURF2 = RM_RA_OPA_SURF(2);

//enum G_RM_ZB_OPA_SURF = RM_ZB_OPA_SURF(1);
//enum G_RM_ZB_OPA_SURF2 = RM_ZB_OPA_SURF(2);
//enum G_RM_ZB_XLU_SURF = RM_ZB_XLU_SURF(1);
//enum G_RM_ZB_XLU_SURF2 = RM_ZB_XLU_SURF(2);
//enum G_RM_ZB_OPA_DECAL = RM_ZB_OPA_DECAL(1);
//enum G_RM_ZB_OPA_DECAL2 = RM_ZB_OPA_DECAL(2);
//enum G_RM_ZB_XLU_DECAL = RM_ZB_XLU_DECAL(1);
//enum G_RM_ZB_XLU_DECAL2 = RM_ZB_XLU_DECAL(2);
//enum G_RM_ZB_CLD_SURF = RM_ZB_CLD_SURF(1);
//enum G_RM_ZB_CLD_SURF2 = RM_ZB_CLD_SURF(2);
//enum G_RM_ZB_OVL_SURF = RM_ZB_OVL_SURF(1);
//enum G_RM_ZB_OVL_SURF2 = RM_ZB_OVL_SURF(2);
//enum G_RM_ZB_PCL_SURF = RM_ZB_PCL_SURF(1);
//enum G_RM_ZB_PCL_SURF2 = RM_ZB_PCL_SURF(2);

//enum G_RM_OPA_SURF = RM_OPA_SURF(1);
//enum G_RM_OPA_SURF2 = RM_OPA_SURF(2);
//enum G_RM_XLU_SURF = RM_XLU_SURF(1);
//enum G_RM_XLU_SURF2 = RM_XLU_SURF(2);
//enum G_RM_CLD_SURF = RM_CLD_SURF(1);
//enum G_RM_CLD_SURF2 = RM_CLD_SURF(2);
//enum G_RM_TEX_EDGE = RM_TEX_EDGE(1);
//enum G_RM_TEX_EDGE2 = RM_TEX_EDGE(2);
//enum G_RM_PCL_SURF = RM_PCL_SURF(1);
//enum G_RM_PCL_SURF2 = RM_PCL_SURF(2);
//enum G_RM_ADD = RM_ADD(1);
//enum G_RM_ADD2 = RM_ADD(2);
//enum G_RM_NOOP = RM_NOOP(1);
//enum G_RM_NOOP2 = RM_NOOP(2);
//enum G_RM_VISCVG = RM_VISCVG(1);
//enum G_RM_VISCVG2 = RM_VISCVG(2);
//enum G_RM_OPA_CI = RM_OPA_CI(1);
//enum G_RM_OPA_CI2 = RM_OPA_CI(2);

//enum G_RM_CUSTOM_AA_ZB_XLU_SURF = RM_CUSTOM_AA_ZB_XLU_SURF(1);
//enum G_RM_CUSTOM_AA_ZB_XLU_SURF2 = RM_CUSTOM_AA_ZB_XLU_SURF(2);

enum G_RM_FOG_SHADE_A = GBL_c1(G_BL_CLR_FOG, G_BL_A_SHADE, G_BL_CLR_IN, G_BL_1MA);
enum G_RM_FOG_PRIM_A = GBL_c1(G_BL_CLR_FOG, G_BL_A_FOG, G_BL_CLR_IN, G_BL_1MA);
enum G_RM_PASS = GBL_c1(G_BL_CLR_IN, G_BL_0, G_BL_CLR_IN, G_BL_1);

/*
 * G_SETCONVERT: K0-5
 */
enum G_CV_K0 = 175;
enum G_CV_K1 = -43;
enum G_CV_K2 = -89;
enum G_CV_K3 = 222;
enum G_CV_K4 = 114;
enum G_CV_K5 = 42;

/*
 * G_SETSCISSOR: interlace mode
 */
enum G_SC_NON_INTERLACE = 0;
enum G_SC_ODD_INTERLACE = 3;
enum G_SC_EVEN_INTERLACE = 2;

/* flags to inhibit pushing of the display list (on branch) */
enum G_DL_PUSH = 0x00;
enum G_DL_NOPUSH = 0x01;

/*
 * BEGIN C-specific section: (typedef's)
 */

/*
 * Data Structures
 *
 * NOTE:
 * The DMA transfer hardware requires 64-bit aligned, 64-bit multiple-
 * sized transfers. This important hardware optimization is unfortunately
 * reflected in the programming interface, with some structures
 * padded and alignment enforced.
 *
 * Since structures are aligned to the boundary of the "worst-case"
 * element, we can't depend on the C compiler to align things
 * properly.
 *
 * 64-bit structure alignment is enforced by wrapping structures with
 * unions that contain a dummy "long long int".  Why this works is
 * explained in the ANSI C Spec, or on page 186 of the second edition
 * of K&R, "The C Programming Language".
 *
 * The price we pay for this is a little awkwardness referencing the
 * structures through the union. There is no memory penalty, since
 * all the structures are at least 64-bits the dummy alignment field
 * does not increase the size of the union.
 *
 * Static initialization of these union structures works because
 * the ANSI C spec states that static initialization for unions
 * works by using the first union element. We put the dummy alignment
 * field last for this reason.
 *
 * (it's possible a newer 64-bit compiler from MIPS might make this
 * easier with a flag, but we can't wait for it...)
 *
 */

/*
 * Vertex (set up for use with colors)
 */

/* x, y, z */

/* x, y, z */

/* texture coord */
/* color & alpha */

/*
 * Vertex (set up for use with normals)
 */

/* x, y, z */

/* x, y, z */

/* texture coord */
/* normal */
/* alpha  */

/* Use this one for colors  */
/* Use this one for normals */

/*
 * Sprite structure
 */

/* 20 bytes for above */

/* padding to bring structure size to 64 bit allignment */

/* Need to make sure this is 64 bit aligned */

/*
 * Triangle face
 */

/*
 * 4x4 matrix, fixed point s15.16 format.
 * First 8 words are integer portion of the 4x4 matrix
 * Last 8 words are the fraction portion of the 4x4 matrix
 */
struct Mtx {
    float[4][4] m;
}

/*
 * Viewport
 */

/*
 *
 * This magic value is the maximum INTEGER z-range of the hardware
 * (there are also 16-bits of fraction, which are introduced during
 * any transformations). This is not just a good idea, it's the law.
 * Feeding the hardware eventual z-coordinates (after any transforms
 * or scaling) bigger than this, will not work.
 *
 * This number is DIFFERENT than G_MAXFBZ, which is the maximum value
 * you want to use to initialize the z-buffer.
 *
 * The reason these are different is mildly interesting, but too long
 * to explain here. It is basically the result of optimizations in the
 * hardware. A more generic API might hide this detail from the users,
 * but we don't have the ucode to do that...
 *
 */
/* 10 bits of integer screen-Z precision */

/*
 * The viewport structure elements have 2 bits of fraction, necessary
 * to accomodate the sub-pixel positioning scaling for the hardware.
 * This can also be exploited to handle odd-sized viewports.
 *
 * Accounting for these fractional bits, using the default projection
 * and viewing matrices, the viewport structure is initialized thusly:
 *
 *		(SCREEN_WD/2)*4, (SCREEN_HT/2)*4, G_MAXZ, 0,
 *		(SCREEN_WD/2)*4, (SCREEN_HT/2)*4, 0, 0,
 */

struct Vp_t {
    short[4] vscale;  /* scale, 2 bits fraction */
    short[4] vtrans;  /* translate, 2 bits fraction */
    /* both the above arrays are padded to 64-bit boundary */
}

union Vp {
    Vp_t  vp;
    ulong force_structure_alignment;
}


/*
 * MOVEMEM indices
 *
 * Each of these indexes an entry in a dmem table
 * which points to a 1-4 word block of dmem in
 * which to store a 1-4 word DMA.
 *
 */

/* 0,4 are reserved by G_MTX */

/* NOTE: this is in moveword table */

/* F3DEX_GBI_2 */

/* NOTE: this is in moveword table */

/* F3DEX_GBI_2 */

/*
 * MOVEWORD indices
 *
 * Each of these indexes an entry in a dmem table
 * which points to a word in dmem in dmem where
 * an immediate word will be stored.
 *
 */
/* NOTE: also used by movemem */

/* F3DEX_GBI_2 */

/* F3DEX_GBI_2 */

/*
 * These are offsets from the address in the dmem table
 */

/*
 * Light structure.
 *
 * Note: only directional (infinite) lights are currently supported.
 *
 * Note: the weird order is for the DMEM alignment benefit of
 * the microcode.
 *
 */

/* diffuse light value (rgba) */

/* copy of diffuse light value (rgba) */

/* direction of light (normalized) */

/* ambient light value (rgba) */

/* copy of ambient light value (rgba) */

/* texture offsets for highlight 1/2 */

/* Don't declare these for F3D_OLD to avoid bss reordering */

/*
 *  Graphics DMA Packet
 */

/*
 * Graphics Immediate Mode Packet types
 */

/*
 * typedef struct {
 * 		int		cmd:8;
 * 		int		pad0:24;
 * 		int		pad1:4;
 * 		int		number:4;
 * 		int		base:24;
 * } Gsegment;
 */

/*
 * RDP Packet types
 */

/* really only 10 bits, extra	*/
/* to account for 1024		*/

/* command			*/
/* X coordinate of upper left	*/
/* Y coordinate of upper left	*/
/* Padding			*/
/* Tile descriptor index	*/
/* X coordinate of lower right	*/
/* Y coordinate of lower right	*/
/* S texture coord at top left	*/
/* T texture coord at top left	*/
/* Change in S per change in X	*/
/* Change in T per change in Y	*/

/*
 * Textured rectangles are 128 bits not 64 bits
 */

/*
 * Generic Gfx Packet
 */

/*
 * This union is the fundamental type of the display list.
 * It is, by law, exactly 64 bits in size.
 *
 * (Edit: except on 64-bit, where it is exactly 128 bit. On little-endian or
 * 64-bit systems, only the 'words' member may be accessed; the rest of the
 * structs don't have matching layouts for now.)
 */

/* use for setscissor also */

/* use for loadblock also, th is dxt */

/*
 * Macros to assemble the graphics display list
 */

/*
 * DMA macros
 */

/* F3DEX_GBI_2 */

/* F3DEX_GBI_2 */

/*
 * F3DEX_GBI_2: G_VTX GBI format was changed.
 *
 *        +--------+----+---+---+----+------+-+
 *  G_VTX |  cmd:8 |0000|  n:8  |0000|v0+n:7|0|
 *        +-+---+--+----+---+---+----+------+-+
 *        | |seg|         address             |
 *        +-+---+-----------------------------+
 */

/*
 * F3DEX_GBI: G_VTX GBI format was changed to support 64 vertice.
 *
 *        +--------+--------+------+----------+
 *  G_VTX |  cmd:8 |  v0:8  |  n:6 |length:10 |
 *        +-+---+--+--------+------+----------+
 *        | |seg|          address            |
 *        +-+---+-----------------------------+
 */

/* F3DEX_GBI_2 */

/* F3DEX_GBI_2 */

/*
 * RSP short command (no DMA required) macros
 */

/* F3DEX_GBI_2 */

/* F3DEX_GBI_2 */

/* Sprite immediate macros, there is also a sprite dma macro above */

/*
 * Note: the SP1Triangle() and line macros multiply the vertex indices
 * by 10, this is an optimization for the microcode.
 */

/***
 ***  1 Triangle
 ***/

/***
 ***  Line
 ***/

/***
 ***  LineW
 ***/
/* these macros are the same as SPLine3D, except they have an
 * additional parameter for width. The width is added to the "minimum"
 * thickness, which is 1.5 pixels. The units for width are in
 * half-pixel units, so a width of 1 translates to (.5 + 1.5) or
 * a 2.0 pixels wide line.
 */

/***
 ***  1 Quadrangle
 ***/

/* F3DEX_GBI_2 */

/***
 ***  1 Triangle
 ***/

/***
 ***  Line
 ***/

/***
 ***  LineW
 ***/
/* these macros are the same as SPLine3D, except they have an
 * additional parameter for width. The width is added to the "minimum"
 * thickness, which is 1.5 pixels. The units for width are in
 * half-pixel units, so a width of 1 translates to (.5 + 1.5) or
 * a 2.0 pixels wide line.
 */

/***
 ***  1 Quadrangle
 ***/

/* F3DEX_GBI_2 */

/***
 ***  2 Triangles
 ***/

/* F3DEX_GBI/F3DLP_GBI */

/*
 * Clipping Macros
 */

/*
 * r should be one of: FRUSTRATIO_1, FRUSTRATIO_2, FRUSTRATIO_3, ... FRUSTRATIO_6
 */

/*
 * Insert values into Matrix
 *
 * where = element of matrix (byte offset)
 * num   = new element (32 bit value replacing 2 int or 2 frac matrix
 *                                 componants
 */

/*
 * Load new matrix directly
 *
 * mptr = pointer to matrix
 */

/* F3DEX_GBI_2 */

/* F3DEX_GBI_2 */

/*
 * Insert values into Points
 *
 * point = point number 0-15
 * where = which element of point to modify (byte offset into point)
 * num   = new value (32 bit)
 */

/*
 *  gSPBranchLessZ   Branch DL if (vtx.z) less than or equal (zval).
 *
 *  dl	 = DL branch to
 *  vtx  = Vertex
 *  zval = Screen depth
 *  near = Near plane
 *  far  = Far  plane
 *  flag = G_BZ_PERSP or G_BZ_ORTHO
 */

/*
 *  gSPBranchLessZraw   Branch DL if (vtx.z) less than or equal (raw zval).
 *
 *  dl	 = DL branch to
 *  vtx  = Vertex
 *  zval = Raw value of screen depth
 */

/*
 * gSPLoadUcode   RSP loads specified ucode.
 *
 * uc_start  = ucode text section start
 * uc_dstart = ucode data section start
 */

/*
 * gSPDma_io  DMA to/from DMEM/IMEM for DEBUG.
 */

/*
 * Lighting Macros
 */

/*
 * n should be one of: NUMLIGHTS_0, NUMLIGHTS_1, ..., NUMLIGHTS_7
 * NOTE: in addition to the number of directional lights specified,
 *       there is always 1 ambient light
 */

/*
 * l should point to a Light struct
 * n should be one of: LIGHT_1, LIGHT_2, ..., LIGHT_8
 * NOTE: the highest numbered light is always the ambient light (eg if there are
 *       3 directional lights defined: gsSPNumLights(NUMLIGHTS_3), then lights
 *       LIGHT_1 through LIGHT_3 will be the directional lights and light
 *       LIGHT_4 will be the ambient light.
 */

/* F3DEX_GBI_2 */

/* F3DEX_GBI_2 */

/*
 * gSPLightColor changes color of light without recalculating light direction
 * col is a 32 bit word with r,g,b,a (alpha is ignored)
 * n should be one of LIGHT_1, LIGHT_2, ..., LIGHT_8
 */

/* These macros use a structure "name" which is init'd with the gdSPDefLights macros*/

/*
 * Reflection/Hiliting Macros
 */

/* F3DEX_GBI_2 */

/* F3DEX_GBI_2 */

/*
 * FOG macros
 * fm = z multiplier
 * fo = z offset
 * FOG FORMULA:    alpha(fog) = (eyespace z) * fm  + fo  CLAMPED 0 to 255
 *   note: (eyespace z) ranges -1 to 1
 *
 * Alternate method of setting fog:
 * min, max: range 0 to 1000: 0=nearplane, 1000=farplane
 * min is where fog begins (usually less than max and often 0)
 * max is where fog is thickest (usually 1000)
 *
 */

/*
 * Macros to turn texture on/off
 */

/*
 * Different version of SPTexture macro, has an additional parameter
 * which is currently reserved in the microcode.
 */

/*
 * Macros to turn texture on/off
 */

/*
 * Different version of SPTexture macro, has an additional parameter
 * which is currently reserved in the microcode.
 */

/* F3DEX_GBI_2 */

/* F3DEX_GBI_2 */

/*
 *	One gSPGeometryMode(pkt,c,s) GBI is equal to these two GBIs.
 *
 *		gSPClearGeometryMode(pkt,c)
 *		gSPSetGeometryMode(pkt,s)
 *
 *	gSPLoadGeometryMode(pkt, word) sets GeometryMode directly.
 */

/* F3DEX_GBI_2 */

/*
 * gsSPGeometryMode
 * In Fast3DEX2 it is better to use this, as the RSP geometry mode
 * is able to be set and cleared in a single command.
 */

/* F3DEX_GBI_2 */

/*
 * RDP setothermode register commands - register shadowed in RSP
 */

/* 'blendmask' is not supported anymore.
 * The bits are reserved for future use.
 * Fri May 26 13:45:55 PDT 1995
 */

/* use these for new code */

/* kept for compatibility */

/*
 * RDP macros
 */

/*
 * SetCombineMode macros are NOT redunant. It allow the C preprocessor
 * to substitute single parameter which includes commas in the token and
 * rescan for higher parameter count macro substitution.
 *
 * eg.	gsDPSetCombineMode(G_CC_MODULATE, G_CC_MODULATE) turns into
 *	gsDPSetCombineLERP(TEXEL0, 0, SHADE, 0, TEXEL0, 0, SHADE, 0,
 *		TEXEL0, 0, SHADE, 0, TEXEL0, 0, SHADE, 0)
 */

/*
 * gDPSetOtherMode (This is for expert user.)
 *
 * This command makes all othermode parameters set.
 * Do not use this command in the same DL with another g*SPSetOtherMode DLs.
 *
 * [Usage]
 *	gDPSetOtherMode(pkt, modeA, modeB)
 *
 *      'modeA' is described all parameters of GroupA GBI command.
 *      'modeB' is also described all parameters of GroupB GBI command.
 *
 *	GroupA:
 *	  gDPPipelineMode, gDPSetCycleType, gSPSetTexturePersp,
 *	  gDPSetTextureDetail, gDPSetTextureLOD, gDPSetTextureLUT,
 *	  gDPSetTextureFilter, gDPSetTextureConvert, gDPSetCombineKey,
 *	  gDPSetColorDither, gDPSetAlphaDither
 *
 *	GroupB:
 *	  gDPSetAlphaCompare, gDPSetDepthSource, gDPSetRenderMode
 *
 *	Use 'OR' operation to get modeA and modeB.
 *
 *	modeA = G_PM_* | G_CYC_* | G_TP_* | G_TD_* | G_TL_* | G_TT_* | G_TF_*
 *		G_TC_* | G_CK_*  | G_CD_* | G_AD_*;
 *
 *	modeB = G_AC_* | G_ZS_*  | G_RM_* | G_RM_*2;
 */

/*
 * Texturing macros
 */

/* These are also defined defined above for Sprite Microcode */

/*
 *  Dxt is the inverse of the number of 64-bit words in a line of
 *  the texture being loaded using the load_block command.  If
 *  there are any 1's to the right of the 11th fractional bit,
 *  dxt should be rounded up.  The following macros accomplish
 *  this.  The 4b macros are a special case since 4-bit textures
 *  are loaded as 8-bit textures.  Dxt is fixed point 1.11. RJM
 */

/*
 *  For RCP 2.0, the maximum number of texels that can be loaded
 *  using a load_block command is 2048.  In order to load the total
 *  4kB of Tmem, change the texel size when loading to be G_IM_SIZ_16b,
 *  then change the tile to the proper texel size after the load.
 *  The g*DPLoadTextureBlock macros already do this, so this change
 *  will be transparent if you use these macros.  If you use
 *  the g*DPLoadBlock macros directly, you will need to handle this
 *  tile manipulation yourself.  RJM.
 */

/* _HW_VERSION_1 */

/*
 *  For RCP 2.0, the maximum number of texels that can be loaded
 *  using a load_block command is 2048.  In order to load the total
 *  4kB of Tmem, change the texel size when loading to be G_IM_SIZ_16b,
 *  then change the tile to the proper texel size after the load.
 *  The g*DPLoadTextureBlock macros already do this, so this change
 *  will be transparent if you use these macros.  If you use
 *  the g*DPLoadBlock macros directly, you will need to handle this
 *  tile manipulation yourself.  RJM.
 */

/* Load fix rww 27jun95 */
/* The S at the end means odd lines are already word Swapped */

/*
 *  Allow tmem address and render tile to be specified.
 *  The S at the end means odd lines are already word Swapped
 */

/*
 *  allows tmem address to be specified
 */

/*
 *  allows tmem address and render tile to be specified
 */

/*
 *  allows tmem address and render tile to be specified
 */

/* Here is the static form of the pre-swapped texture block loading */
/* See gDPLoadTextureBlockS() for reference.  Basically, just don't
   calculate DxT, use 0 */

/*
 *  Allow tmem address to be specified
 */

/*
 *  Allow tmem address and render_tile to be specified
 */

/*
 *  Allow tmem address and render_tile to be specified, useful when loading
 *  mutilple tiles at a time.
 */

/*
 *  Allows tmem and render tile to be specified.  Useful when loading
 *  several tiles at a time.
 *
 *  Here is the static form of the pre-swapped texture block loading
 *  See gDPLoadTextureBlockS() for reference.  Basically, just don't
 *  calculate DxT, use 0
 */

/* Load fix rww 27jun95 */
/* The S at the end means odd lines are already word Swapped */

/*
 *  4-bit load block.  Useful when loading multiple tiles
 */

/*
 *  4-bit load block.  Allows tmem and render tile to be specified.  Useful when
 *  loading multiple tiles.  The S means odd lines are already word swapped.
 */

/*
 *  4-bit load block.  Allows tmem address and render tile to be specified.
 *  Useful when loading multiple tiles.
 */

/*
 *  4-bit load block.  Allows tmem address and render tile to be specified.
 *  Useful when loading multiple tiles.  S means odd lines are already swapped.
 */

/*
 *  Allows tmem address to be specified
 */

/******** WORKAROUND hw 1 load tile bug ********/

/* HW_VERSION_1 */

/*
 *  Load texture tile.  Allows tmem address and render tile to be specified.
 *  Useful for loading multiple tiles.
 */

/*
 *  Load texture tile.  Allows tmem address and render tile to be specified.
 *  Useful for loading multiple tiles.
 */

/*
 *  Load texture tile.  Allows tmem address and render tile to be specified.
 *  Useful for loading multiple tiles.
 */

/*
 *  Load texture tile.  Allows tmem address and render tile to be specified.
 *  Useful for loading multiple tiles.
 */

/*
 *  Load a 16-entry palette (for 4-bit CI textures)
 *  Assumes a 16 entry tlut is being loaded, palette # is 0-15
 */

/* **** WORKAROUND hardware 1 load_tlut bug ****** */

/* _HW_VERSION_1 */

/*
 *  Load a 16-entry palette (for 4-bit CI textures)
 *  Assumes a 16 entry tlut is being loaded, palette # is 0-15
 */

/* **** WORKAROUND hardware 1 load_tlut bug ****** */

/* _HW_VERSION_1 */

/*
 *  Load a 256-entry palette (for 8-bit CI textures)
 *  Assumes a 256 entry tlut is being loaded, palette # is not used
 */

/* **** WORKAROUND hardware 1 load_tlut bug ****** */

/* _HW_VERSION_1 */

/* **** WORKAROUND hardware 1 load_tlut bug ****** */

/* _HW_VERSION_1 */

/* **** WORKAROUND hardware 1 load_tlut bug ****** */

/* _HW_VERSION_1 */

/* **** WORKAROUND hardware 1 load_tlut bug ****** */

/* _HW_VERSION_1 */

/* Fraction never used in fill */

/* like gDPFillRectangle but accepts negative arguments */

/* Notice that textured rectangles are 128-bit commands, therefore
 * gsDPTextureRectangle() should not be used in display lists
 * under normal circumstances (use gsSPTextureRectangle()).
 * That is also why there is no gDPTextureRectangle() macros.
 */

/* like gSPTextureRectangle but accepts negative position arguments */

/* like gSPTextureRectangle but accepts negative position arguments */

/* _LANGUAGE_C */

/* _GBI_H_ */

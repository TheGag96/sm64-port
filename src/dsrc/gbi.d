module gbi;

/**************************************************************************
 *									  *
 *		 Copyright (C) 1994, Silicon Graphics, Inc.		  *
 *									  *
 *  These coded instructions, statements, and computer programs  contain  *
 *  unpublished  proprietary  information of Silicon Graphics, Inc., and  *
 *  are protected by Federal copyright law.  They  may  not be disclosed  *
 *  to  third  parties  or copied or duplicated in any form, in whole or  *
 *  in part, without the prior written consent of Silicon Graphics, Inc.  *
 *									  *
 **************************************************************************/
/**************************************************************************
 *
 *  $Revision: 1.141 $
 *  $Date: 1999/09/03 03:43:08 $
 *  $Source: /exdisk2/cvs/N64OS/Master/cvsmdev2/PR/include/gbi.h,v $
 *
 **************************************************************************/

import ultra64, mbi;
import core.stdc.config;
import core.stdc.stdint;

extern (C):

/*
 * To use the F3DEX ucodes, define F3DEX_GBI before include this file.
 *
 *     #define  F3DEX_GBI
 *     #include <ultra64.h>
 *
 *     or
 *
 *     cc -c -DF3DEX_GBI -I.... foo.c
 *
 */

/**************************************************************************
 *
 * Graphics Binary Interface
 *
 **************************************************************************/

/*
 * Graphics Commands, 'xxx' parts may be generated from ucode
 *
 * The command format is
 *
 *	|00xxxxxx| = DMA		0,..,127
 *	|10xxxxxx| = Immediate Mode	-65,..,-128
 *	|11xxxxxx| = RDP cmds		-1,..,-64
 *
 * Note: in order for the RSP microcode to process RDP commands opaquely,
 * we need to further identify those RDP commands that need DRAM address
 * "fixup". To do this, we have the dummy command G_RDP_ADDR_FIXUP, and
 * all |RDP commands| less than this are commands with embedded DRAM
 * addresses. Further, the format of these commands should be similar so
 * only one fixup routine is needed.
 *
 * Further explanation:
 * The names of the commands are somewhat misleading. Here is clarification:
 *
 *	- a 'DMA' type command has a pointer to additional data and
 *	  causes a DMA transfer to bring that into DMEM.
 *
 *	- an 'Immediate' type command isn't really 'immediate', in the
 *	  traditional sense. This just means that the entire command fits
 *	  in the 64-bit word, and the ucode can execute it 'immediately'
 *	  without additional memory transfers.
 *
 *	- an 'RDP' command is identified as such because the RDP
 *	  commands can be passed-thru the RSP and sent to the RDP
 *	  directly. One further confusing thing, is that some 'DP'
 *	  macros below actually generate immediate commands, not
 *	  not direct DP commands.
 *
 * IMPLEMENTATION NOTE:
 * There is another group of RDP commands that includes the triangle commands
 * generated by the RSP code. These are the raw commands the rasterizer
 * hardware chews on, with slope info, etc. They will follow the RDP
 * ordering...
 *
 * IMPLEMENTATION NOTE:
 * The RDP hardware has some of these bit patterns wired up. If the hardware
 * changes, we must adjust this table, likewise we can't change/add things
 * once the hardware is frozen. (actually, the RDP hardware only looks at
 * the lower 6 bits of the command byte)
 *
 */

enum G_NOOP = 0x00;
enum G_RDPHALF_2 = 0xf1;
enum G_SETOTHERMODE_H = 0xe3;
enum G_SETOTHERMODE_L = 0xe2;
enum G_RDPHALF_1 = 0xe1;
enum G_SPNOOP = 0xe0;
enum G_ENDDL = 0xdf;
enum G_DL = 0xde;
enum G_LOAD_UCODE = 0xdd;
enum G_MOVEMEM = 0xdc;
enum G_MOVEWORD = 0xdb;
enum G_MTX = 0xda;
enum G_GEOMETRYMODE = 0xd9;
enum G_POPMTX = 0xd8;
enum G_TEXTURE = 0xd7;
enum G_DMA_IO = 0xd6;
enum G_SPECIAL_1 = 0xd5;
enum G_SPECIAL_2 = 0xd4;
enum G_SPECIAL_3 = 0xd3;

enum G_VTX = 0x01;
enum G_MODIFYVTX = 0x02;
enum G_CULLDL = 0x03;
enum G_BRANCH_Z = 0x04;
enum G_TRI1 = 0x05;
enum G_TRI2 = 0x06;
enum G_QUAD = 0x07;
enum G_LINE3D = 0x08;
/* F3DEX_GBI_2 */

/* DMA commands: */
/* handle 0 gracefully */

/* not implemeted */
/* move a block of memory (up to 4 words) to dmem */

/* not implemeted */

/* not implemeted */
/* not implemeted */
/* sprite command */

/* IMMEDIATE commands: */

/* We are overloading 2 of the immediate commands
   to keep the byte alignment of dmem the same */

/* RDP commands: */
/*   0 */

/* F3DEX_GBI_2 */

/* RDP commands: */
enum G_SETCIMG = 0xff; /*  -1 */
enum G_SETZIMG = 0xfe; /*  -2 */
enum G_SETTIMG = 0xfd; /*  -3 */
enum G_SETCOMBINE = 0xfc; /*  -4 */
enum G_SETENVCOLOR = 0xfb; /*  -5 */
enum G_SETPRIMCOLOR = 0xfa; /*  -6 */
enum G_SETBLENDCOLOR = 0xf9; /*  -7 */
enum G_SETFOGCOLOR = 0xf8; /*  -8 */
enum G_SETFILLCOLOR = 0xf7; /*  -9 */
enum G_FILLRECT = 0xf6; /* -10 */
enum G_SETTILE = 0xf5; /* -11 */
enum G_LOADTILE = 0xf4; /* -12 */
enum G_LOADBLOCK = 0xf3; /* -13 */
enum G_SETTILESIZE = 0xf2; /* -14 */
enum G_LOADTLUT = 0xf0; /* -16 */
enum G_RDPSETOTHERMODE = 0xef; /* -17 */
enum G_SETPRIMDEPTH = 0xee; /* -18 */
enum G_SETSCISSOR = 0xed; /* -19 */
enum G_SETCONVERT = 0xec; /* -20 */
enum G_SETKEYR = 0xeb; /* -21 */
enum G_SETKEYGB = 0xea; /* -22 */
enum G_RDPFULLSYNC = 0xe9; /* -23 */
enum G_RDPTILESYNC = 0xe8; /* -24 */
enum G_RDPPIPESYNC = 0xe7; /* -25 */
enum G_RDPLOADSYNC = 0xe6; /* -26 */
enum G_TEXRECTFLIP = 0xe5; /* -27 */
enum G_TEXRECT = 0xe4; /* -28 */

/*
 * The following commands are the "generated" RDP commands; the user
 * never sees them, the RSP microcode generates them.
 *
 * The layout of the bits is magical, to save work in the ucode.
 * These id's are -56, -52, -54, -50, -55, -51, -53, -49, ...
 *                                 edge, shade, texture, zbuff bits:  estz
 */
enum G_TRI_FILL = 0xc8; /* fill triangle:            11001000 */
enum G_TRI_SHADE = 0xcc; /* shade triangle:           11001100 */
enum G_TRI_TXTR = 0xca; /* texture triangle:         11001010 */
enum G_TRI_SHADE_TXTR = 0xce; /* shade, texture triangle:  11001110 */
enum G_TRI_FILL_ZBUFF = 0xc9; /* fill, zbuff triangle:     11001001 */
enum G_TRI_SHADE_ZBUFF = 0xcd; /* shade, zbuff triangle:    11001101 */
enum G_TRI_TXTR_ZBUFF = 0xcb; /* texture, zbuff triangle:  11001011 */
enum G_TRI_SHADE_TXTR_ZBUFF = 0xcf; /* shade, txtr, zbuff trngl: 11001111 */

/*
 * A TRI_FILL triangle is just the edges. You need to set the DP
 * to use primcolor, in order to see anything. (it is NOT a triangle
 * that gets rendered in 'fill mode'. Triangles can't be rendered
 * in 'fill mode')
 *
 * A TRI_SHADE is a gouraud triangle that has colors interpolated.
 * Flat-shaded triangles (from the software) are still gouraud shaded,
 * it's just the colors are all the same and the deltas are 0.
 *
 * Other triangle types, and combinations are more obvious.
 */

/* masks to build RDP triangle commands: */
enum G_RDP_TRI_FILL_MASK = 0x08;
enum G_RDP_TRI_SHADE_MASK = 0x04;
enum G_RDP_TRI_TXTR_MASK = 0x02;
enum G_RDP_TRI_ZBUFF_MASK = 0x01;

/*
 * HACK:
 * This is a dreadful hack. For version 1.0 hardware, there are still
 * some 'bowtie' hangs. This parameter can be increased to avoid
 * the hangs. Every increase of 4 chops one scanline off of every
 * triangle. Values of 4,8,12 should be sufficient to avoid any
 * bowtie hang.
 *
 * Change this value, then recompile ALL of your program (including static
 * display lists!)
 *
 * THIS WILL BE REMOVED FOR HARDWARE VERSION 2.0!
 */
enum BOWTIE_VAL = 0;

/* gets added to RDP command, in order to test for addres fixup: */
enum G_RDP_ADDR_FIXUP = 3; /* |RDP cmds| <= this, do addr fixup */

/* macros for command parsing: */
extern (D) auto GDMACMD(T)(auto ref T x)
{
    return x;
}

extern (D) auto GIMMCMD(T)(auto ref T x)
{
    return G_IMMFIRST - x;
}

extern (D) auto GRDPCMD(T)(auto ref T x)
{
    return 0xff - x;
}

enum G_DMACMDSIZ = 128;
enum G_IMMCMDSIZ = 64;
enum G_RDPCMDSIZ = 64;

/*
 * Coordinate shift values, number of bits of fraction
 */
enum G_TEXTURE_IMAGE_FRAC = 2;
enum G_TEXTURE_SCALE_FRAC = 16;
enum G_SCALE_FRAC = 8;
enum G_ROTATE_FRAC = 16;

/*
 * Parameters to graphics commands
 */

/*
 * Data packing macros
 */

/*
 * Maximum z-buffer value, used to initialize the z-buffer.
 * Note : this number is NOT the viewport z-scale constant.
 * See the comment next to G_MAXZ for more info.
 */
enum G_MAXFBZ = 0x3fff; /* 3b exp, 11b mantissa */

extern (D) auto GPACK_RGBA5551(T0, T1, T2, T3)(auto ref T0 r, auto ref T1 g, auto ref T2 b, auto ref T3 a)
{
    return ((r << 8) & 0xf800) | ((g << 3) & 0x7c0) | ((b >> 2) & 0x3e) | (a & 0x1);
}

extern (D) auto GPACK_ZDZ(T0, T1)(auto ref T0 z, auto ref T1 dz)
{
    return z << 2 | dz;
}

/*
 * G_MTX: parameter flags
 */
enum G_MTX_MODELVIEW = 0x00; /* matrix types */
enum G_MTX_PROJECTION = 0x04;
enum G_MTX_MUL = 0x00; /* concat or load */
enum G_MTX_LOAD = 0x02;
enum G_MTX_NOPUSH = 0x00; /* push or not */
enum G_MTX_PUSH = 0x01;
/* F3DEX_GBI_2 */
/* matrix types */

/* concat or load */

/* push or not */

/* F3DEX_GBI_2 */

/*
 * flags for G_SETGEOMETRYMODE
 * (this rendering state is maintained in RSP)
 *
 * DO NOT USE THE LOW 8 BITS OF GEOMETRYMODE:
 * The weird bit-ordering is for the micro-code: the lower byte
 * can be OR'd in with G_TRI_SHADE (11001100) to construct
 * the triangle command directly. Don't break it...
 *
 * DO NOT USE THE HIGH 8 BITS OF GEOMETRYMODE:
 * The high byte is OR'd with 0x703 to form the clip code mask.
 * If it is set to 0x04, this will cause near clipping to occur.
 * If it is zero, near clipping will not occur.
 *
 * Further explanation:
 * G_SHADE is necessary in order to see the color that you passed
 * down with the vertex. If G_SHADE isn't set, you need to set the DP
 * appropriately and use primcolor to see anything.
 *
 * G_SHADING_SMOOTH enabled means use all 3 colors of the triangle.
 * If it is not set, then do 'flat shading', where only one vertex color
 * is used (and all 3 vertices are set to that same color by the ucode)
 * See the man page for gSP1Triangle().
 *
 */
enum G_ZBUFFER = 0x00000001;
enum G_SHADE = 0x00000004; /* enable Gouraud interp */
/* rest of low byte reserved for setup ucode */
enum G_TEXTURE_ENABLE = 0x00000000; /* Ignored               */
enum G_SHADING_SMOOTH = 0x00200000; /* flat or smooth shaded */
enum G_CULL_FRONT = 0x00000200;
enum G_CULL_BACK = 0x00000400;
enum G_CULL_BOTH = 0x00000600; /* To make code cleaner */

/* Microcode use only */
/* flat or smooth shaded */

/* To make code cleaner */

enum G_FOG = 0x00010000;
enum G_LIGHTING = 0x00020000;
enum G_TEXTURE_GEN = 0x00040000;
enum G_TEXTURE_GEN_LINEAR = 0x00080000;
enum G_LOD = 0x00100000; /* NOT IMPLEMENTED */
enum G_CLIPPING = 0x00800000;

/* NOT IMPLEMENTED */

/* Need these defined for Sprite Microcode */

/*
 * G_SETIMG fmt: set image formats
 */
enum G_IM_FMT_RGBA = 0;
enum G_IM_FMT_YUV = 1;
enum G_IM_FMT_CI = 2;
enum G_IM_FMT_IA = 3;
enum G_IM_FMT_I = 4;

/*
 * G_SETIMG siz: set image pixel size
 */
enum G_IM_SIZ_4b = 0;
enum G_IM_SIZ_8b = 1;
enum G_IM_SIZ_16b = 2;
enum G_IM_SIZ_32b = 3;
enum G_IM_SIZ_DD = 5;

enum G_IM_SIZ_4b_BYTES = 0;
enum G_IM_SIZ_4b_TILE_BYTES = G_IM_SIZ_4b_BYTES;
enum G_IM_SIZ_4b_LINE_BYTES = G_IM_SIZ_4b_BYTES;

enum G_IM_SIZ_8b_BYTES = 1;
enum G_IM_SIZ_8b_TILE_BYTES = G_IM_SIZ_8b_BYTES;
enum G_IM_SIZ_8b_LINE_BYTES = G_IM_SIZ_8b_BYTES;

enum G_IM_SIZ_16b_BYTES = 2;
enum G_IM_SIZ_16b_TILE_BYTES = G_IM_SIZ_16b_BYTES;
enum G_IM_SIZ_16b_LINE_BYTES = G_IM_SIZ_16b_BYTES;

enum G_IM_SIZ_32b_BYTES = 4;
enum G_IM_SIZ_32b_TILE_BYTES = 2;
enum G_IM_SIZ_32b_LINE_BYTES = 2;

enum G_IM_SIZ_4b_LOAD_BLOCK = G_IM_SIZ_16b;
enum G_IM_SIZ_8b_LOAD_BLOCK = G_IM_SIZ_16b;
enum G_IM_SIZ_16b_LOAD_BLOCK = G_IM_SIZ_16b;
enum G_IM_SIZ_32b_LOAD_BLOCK = G_IM_SIZ_32b;

enum G_IM_SIZ_4b_SHIFT = 2;
enum G_IM_SIZ_8b_SHIFT = 1;
enum G_IM_SIZ_16b_SHIFT = 0;
enum G_IM_SIZ_32b_SHIFT = 0;

enum G_IM_SIZ_4b_INCR = 3;
enum G_IM_SIZ_8b_INCR = 1;
enum G_IM_SIZ_16b_INCR = 0;
enum G_IM_SIZ_32b_INCR = 0;

/*
 * G_SETCOMBINE: color combine modes
 */
/* Color combiner constants: */
enum G_CCMUX_COMBINED = 0;
enum G_CCMUX_TEXEL0 = 1;
enum G_CCMUX_TEXEL1 = 2;
enum G_CCMUX_PRIMITIVE = 3;
enum G_CCMUX_SHADE = 4;
enum G_CCMUX_ENVIRONMENT = 5;
enum G_CCMUX_CENTER = 6;
enum G_CCMUX_SCALE = 6;
enum G_CCMUX_COMBINED_ALPHA = 7;
enum G_CCMUX_TEXEL0_ALPHA = 8;
enum G_CCMUX_TEXEL1_ALPHA = 9;
enum G_CCMUX_PRIMITIVE_ALPHA = 10;
enum G_CCMUX_SHADE_ALPHA = 11;
enum G_CCMUX_ENV_ALPHA = 12;
enum G_CCMUX_LOD_FRACTION = 13;
enum G_CCMUX_PRIM_LOD_FRAC = 14;
enum G_CCMUX_NOISE = 7;
enum G_CCMUX_K4 = 7;
enum G_CCMUX_K5 = 15;
enum G_CCMUX_1 = 6;
enum G_CCMUX_0 = 31;

/* Alpha combiner constants: */
enum G_ACMUX_COMBINED = 0;
enum G_ACMUX_TEXEL0 = 1;
enum G_ACMUX_TEXEL1 = 2;
enum G_ACMUX_PRIMITIVE = 3;
enum G_ACMUX_SHADE = 4;
enum G_ACMUX_ENVIRONMENT = 5;
enum G_ACMUX_LOD_FRACTION = 0;
enum G_ACMUX_PRIM_LOD_FRAC = 6;
enum G_ACMUX_1 = 6;
enum G_ACMUX_0 = 7;

/* typical CC cycle 1 modes */

//enum G_CC_MODULATERGB = G_CC_MODULATEI;
//enum G_CC_MODULATERGBDECALA = G_CC_MODULATEIDECALA;
//enum G_CC_MODULATERGBFADE = G_CC_MODULATEIFADE;

//enum G_CC_MODULATERGBA = G_CC_MODULATEIA;
//enum G_CC_MODULATERGBFADEA = G_CC_MODULATEIFADEA;

//enum G_CC_MODULATERGB_PRIM = G_CC_MODULATEI_PRIM;
//enum G_CC_MODULATERGBA_PRIM = G_CC_MODULATEIA_PRIM;
//enum G_CC_MODULATERGBDECALA_PRIM = G_CC_MODULATEIDECALA_PRIM;

/* oddball modes */
/* used for 1-cycle sparse mip-maps, primitive color has color of lowest LOD */

/* typical CC cycle 1 modes, usually followed by other cycle 2 modes */

/*
 *  One-cycle color convert operation
 */

/*
 *  NOTE: YUV2RGB expects TF step1 color conversion to occur in 2nd clock.
 * Therefore, CC looks for step1 results in TEXEL1
 */

/* typical CC cycle 2 modes */
//enum G_CC_MODULATERGB2 = G_CC_MODULATEI2;
//enum G_CC_MODULATERGBA2 = G_CC_MODULATEIA2;
//enum G_CC_MODULATERGB_PRIM2 = G_CC_MODULATEI_PRIM2;
//enum G_CC_MODULATERGBA_PRIM2 = G_CC_MODULATEIA_PRIM2;
/*
 * ?
#define	G_CC_DECALRGBA2		COMBINED, SHADE, COMBINED_ALPHA, SHADE, 0, 0, 0, SHADE
*/

/*
 * G_SETOTHERMODE_L sft: shift count
 */
enum G_MDSFT_ALPHACOMPARE = 0;
enum G_MDSFT_ZSRCSEL = 2;
enum G_MDSFT_RENDERMODE = 3;
enum G_MDSFT_BLENDER = 16;

/*
 * G_SETOTHERMODE_H sft: shift count
 */
enum G_MDSFT_BLENDMASK = 0; /* unsupported */
enum G_MDSFT_ALPHADITHER = 4;
enum G_MDSFT_RGBDITHER = 6;

enum G_MDSFT_COMBKEY = 8;
enum G_MDSFT_TEXTCONV = 9;
enum G_MDSFT_TEXTFILT = 12;
enum G_MDSFT_TEXTLUT = 14;
enum G_MDSFT_TEXTLOD = 16;
enum G_MDSFT_TEXTDETAIL = 17;
enum G_MDSFT_TEXTPERSP = 19;
enum G_MDSFT_CYCLETYPE = 20;
enum G_MDSFT_COLORDITHER = 22; /* unsupported in HW 2.0 */
enum G_MDSFT_PIPELINE = 23;

/* G_SETOTHERMODE_H gPipelineMode */
enum G_PM_1PRIMITIVE = 1 << G_MDSFT_PIPELINE;
enum G_PM_NPRIMITIVE = 0 << G_MDSFT_PIPELINE;

/* G_SETOTHERMODE_H gSetCycleType */
enum G_CYC_1CYCLE = 0 << G_MDSFT_CYCLETYPE;
enum G_CYC_2CYCLE = 1 << G_MDSFT_CYCLETYPE;
enum G_CYC_COPY = 2 << G_MDSFT_CYCLETYPE;
enum G_CYC_FILL = 3 << G_MDSFT_CYCLETYPE;

/* G_SETOTHERMODE_H gSetTexturePersp */
enum G_TP_NONE = 0 << G_MDSFT_TEXTPERSP;
enum G_TP_PERSP = 1 << G_MDSFT_TEXTPERSP;

/* G_SETOTHERMODE_H gSetTextureDetail */
enum G_TD_CLAMP = 0 << G_MDSFT_TEXTDETAIL;
enum G_TD_SHARPEN = 1 << G_MDSFT_TEXTDETAIL;
enum G_TD_DETAIL = 2 << G_MDSFT_TEXTDETAIL;

/* G_SETOTHERMODE_H gSetTextureLOD */
enum G_TL_TILE = 0 << G_MDSFT_TEXTLOD;
enum G_TL_LOD = 1 << G_MDSFT_TEXTLOD;

/* G_SETOTHERMODE_H gSetTextureLUT */
enum G_TT_NONE = 0 << G_MDSFT_TEXTLUT;
enum G_TT_RGBA16 = 2 << G_MDSFT_TEXTLUT;
enum G_TT_IA16 = 3 << G_MDSFT_TEXTLUT;

/* G_SETOTHERMODE_H gSetTextureFilter */
enum G_TF_POINT = 0 << G_MDSFT_TEXTFILT;
enum G_TF_AVERAGE = 3 << G_MDSFT_TEXTFILT;
enum G_TF_BILERP = 2 << G_MDSFT_TEXTFILT;

/* G_SETOTHERMODE_H gSetTextureConvert */
enum G_TC_CONV = 0 << G_MDSFT_TEXTCONV;
enum G_TC_FILTCONV = 5 << G_MDSFT_TEXTCONV;
enum G_TC_FILT = 6 << G_MDSFT_TEXTCONV;

/* G_SETOTHERMODE_H gSetCombineKey */
enum G_CK_NONE = 0 << G_MDSFT_COMBKEY;
enum G_CK_KEY = 1 << G_MDSFT_COMBKEY;

/* G_SETOTHERMODE_H gSetColorDither */
enum G_CD_MAGICSQ = 0 << G_MDSFT_RGBDITHER;
enum G_CD_BAYER = 1 << G_MDSFT_RGBDITHER;
enum G_CD_NOISE = 2 << G_MDSFT_RGBDITHER;

enum G_CD_DISABLE = 3 << G_MDSFT_RGBDITHER;
enum G_CD_ENABLE = G_CD_NOISE; /* HW 1.0 compatibility mode */

/* G_SETOTHERMODE_H gSetAlphaDither */
enum G_AD_PATTERN = 0 << G_MDSFT_ALPHADITHER;
enum G_AD_NOTPATTERN = 1 << G_MDSFT_ALPHADITHER;
enum G_AD_NOISE = 2 << G_MDSFT_ALPHADITHER;
enum G_AD_DISABLE = 3 << G_MDSFT_ALPHADITHER;

/* G_SETOTHERMODE_L gSetAlphaCompare */
enum G_AC_NONE = 0 << G_MDSFT_ALPHACOMPARE;
enum G_AC_THRESHOLD = 1 << G_MDSFT_ALPHACOMPARE;
enum G_AC_DITHER = 3 << G_MDSFT_ALPHACOMPARE;

/* G_SETOTHERMODE_L gSetDepthSource */
enum G_ZS_PIXEL = 0 << G_MDSFT_ZSRCSEL;
enum G_ZS_PRIM = 1 << G_MDSFT_ZSRCSEL;

/* G_SETOTHERMODE_L gSetRenderMode */
enum AA_EN = 0x8;
enum Z_CMP = 0x10;
enum Z_UPD = 0x20;
enum IM_RD = 0x40;
enum CLR_ON_CVG = 0x80;
enum CVG_DST_CLAMP = 0;
enum CVG_DST_WRAP = 0x100;
enum CVG_DST_FULL = 0x200;
enum CVG_DST_SAVE = 0x300;
enum ZMODE_OPA = 0;
enum ZMODE_INTER = 0x400;
enum ZMODE_XLU = 0x800;
enum ZMODE_DEC = 0xc00;
enum CVG_X_ALPHA = 0x1000;
enum ALPHA_CVG_SEL = 0x2000;
enum FORCE_BL = 0x4000;
enum TEX_EDGE = 0x0000; /* used to be 0x8000 */

enum G_BL_CLR_IN = 0;
enum G_BL_CLR_MEM = 1;
enum G_BL_CLR_BL = 2;
enum G_BL_CLR_FOG = 3;
enum G_BL_1MA = 0;
enum G_BL_A_MEM = 1;
enum G_BL_A_IN = 0;
enum G_BL_A_FOG = 1;
enum G_BL_A_SHADE = 2;
enum G_BL_1 = 2;
enum G_BL_0 = 3;

extern (D) auto GBL_c1(T0, T1, T2, T3)(auto ref T0 m1a, auto ref T1 m1b, auto ref T2 m2a, auto ref T3 m2b)
{
    return m1a << 30 | m1b << 26 | m2a << 22 | m2b << 18;
}

extern (D) auto GBL_c2(T0, T1, T2, T3)(auto ref T0 m1a, auto ref T1 m1b, auto ref T2 m2a, auto ref T3 m2b)
{
    return m1a << 28 | m1b << 24 | m2a << 20 | m2b << 16;
}

/* for rendering to an 8-bit framebuffer */

/* Custom version of RM_AA_ZB_XLU_SURF with Z_UPD */
//extern (D) auto RM_CUSTOM_AA_ZB_XLU_SURF(T)(auto ref T clk)
//{
//    return RM_AA_ZB_XLU_SURF(clk) | Z_UPD;
//}

//enum G_RM_AA_ZB_OPA_SURF = RM_AA_ZB_OPA_SURF(1);
//enum G_RM_AA_ZB_OPA_SURF2 = RM_AA_ZB_OPA_SURF(2);
//enum G_RM_AA_ZB_XLU_SURF = RM_AA_ZB_XLU_SURF(1);
//enum G_RM_AA_ZB_XLU_SURF2 = RM_AA_ZB_XLU_SURF(2);
//enum G_RM_AA_ZB_OPA_DECAL = RM_AA_ZB_OPA_DECAL(1);
//enum G_RM_AA_ZB_OPA_DECAL2 = RM_AA_ZB_OPA_DECAL(2);
//enum G_RM_AA_ZB_XLU_DECAL = RM_AA_ZB_XLU_DECAL(1);
//enum G_RM_AA_ZB_XLU_DECAL2 = RM_AA_ZB_XLU_DECAL(2);
//enum G_RM_AA_ZB_OPA_INTER = RM_AA_ZB_OPA_INTER(1);
//enum G_RM_AA_ZB_OPA_INTER2 = RM_AA_ZB_OPA_INTER(2);
//enum G_RM_AA_ZB_XLU_INTER = RM_AA_ZB_XLU_INTER(1);
//enum G_RM_AA_ZB_XLU_INTER2 = RM_AA_ZB_XLU_INTER(2);
//enum G_RM_AA_ZB_XLU_LINE = RM_AA_ZB_XLU_LINE(1);
//enum G_RM_AA_ZB_XLU_LINE2 = RM_AA_ZB_XLU_LINE(2);
//enum G_RM_AA_ZB_DEC_LINE = RM_AA_ZB_DEC_LINE(1);
//enum G_RM_AA_ZB_DEC_LINE2 = RM_AA_ZB_DEC_LINE(2);
//enum G_RM_AA_ZB_TEX_EDGE = RM_AA_ZB_TEX_EDGE(1);
//enum G_RM_AA_ZB_TEX_EDGE2 = RM_AA_ZB_TEX_EDGE(2);
//enum G_RM_AA_ZB_TEX_INTER = RM_AA_ZB_TEX_INTER(1);
//enum G_RM_AA_ZB_TEX_INTER2 = RM_AA_ZB_TEX_INTER(2);
//enum G_RM_AA_ZB_SUB_SURF = RM_AA_ZB_SUB_SURF(1);
//enum G_RM_AA_ZB_SUB_SURF2 = RM_AA_ZB_SUB_SURF(2);
//enum G_RM_AA_ZB_PCL_SURF = RM_AA_ZB_PCL_SURF(1);
//enum G_RM_AA_ZB_PCL_SURF2 = RM_AA_ZB_PCL_SURF(2);
//enum G_RM_AA_ZB_OPA_TERR = RM_AA_ZB_OPA_TERR(1);
//enum G_RM_AA_ZB_OPA_TERR2 = RM_AA_ZB_OPA_TERR(2);
//enum G_RM_AA_ZB_TEX_TERR = RM_AA_ZB_TEX_TERR(1);
//enum G_RM_AA_ZB_TEX_TERR2 = RM_AA_ZB_TEX_TERR(2);
//enum G_RM_AA_ZB_SUB_TERR = RM_AA_ZB_SUB_TERR(1);
//enum G_RM_AA_ZB_SUB_TERR2 = RM_AA_ZB_SUB_TERR(2);

//enum G_RM_RA_ZB_OPA_SURF = RM_RA_ZB_OPA_SURF(1);
//enum G_RM_RA_ZB_OPA_SURF2 = RM_RA_ZB_OPA_SURF(2);
//enum G_RM_RA_ZB_OPA_DECAL = RM_RA_ZB_OPA_DECAL(1);
//enum G_RM_RA_ZB_OPA_DECAL2 = RM_RA_ZB_OPA_DECAL(2);
//enum G_RM_RA_ZB_OPA_INTER = RM_RA_ZB_OPA_INTER(1);
//enum G_RM_RA_ZB_OPA_INTER2 = RM_RA_ZB_OPA_INTER(2);

//enum G_RM_AA_OPA_SURF = RM_AA_OPA_SURF(1);
//enum G_RM_AA_OPA_SURF2 = RM_AA_OPA_SURF(2);
//enum G_RM_AA_XLU_SURF = RM_AA_XLU_SURF(1);
//enum G_RM_AA_XLU_SURF2 = RM_AA_XLU_SURF(2);
//enum G_RM_AA_XLU_LINE = RM_AA_XLU_LINE(1);
//enum G_RM_AA_XLU_LINE2 = RM_AA_XLU_LINE(2);
//enum G_RM_AA_DEC_LINE = RM_AA_DEC_LINE(1);
//enum G_RM_AA_DEC_LINE2 = RM_AA_DEC_LINE(2);
//enum G_RM_AA_TEX_EDGE = RM_AA_TEX_EDGE(1);
//enum G_RM_AA_TEX_EDGE2 = RM_AA_TEX_EDGE(2);
//enum G_RM_AA_SUB_SURF = RM_AA_SUB_SURF(1);
//enum G_RM_AA_SUB_SURF2 = RM_AA_SUB_SURF(2);
//enum G_RM_AA_PCL_SURF = RM_AA_PCL_SURF(1);
//enum G_RM_AA_PCL_SURF2 = RM_AA_PCL_SURF(2);
//enum G_RM_AA_OPA_TERR = RM_AA_OPA_TERR(1);
//enum G_RM_AA_OPA_TERR2 = RM_AA_OPA_TERR(2);
//enum G_RM_AA_TEX_TERR = RM_AA_TEX_TERR(1);
//enum G_RM_AA_TEX_TERR2 = RM_AA_TEX_TERR(2);
//enum G_RM_AA_SUB_TERR = RM_AA_SUB_TERR(1);
//enum G_RM_AA_SUB_TERR2 = RM_AA_SUB_TERR(2);

//enum G_RM_RA_OPA_SURF = RM_RA_OPA_SURF(1);
//enum G_RM_RA_OPA_SURF2 = RM_RA_OPA_SURF(2);

//enum G_RM_ZB_OPA_SURF = RM_ZB_OPA_SURF(1);
//enum G_RM_ZB_OPA_SURF2 = RM_ZB_OPA_SURF(2);
//enum G_RM_ZB_XLU_SURF = RM_ZB_XLU_SURF(1);
//enum G_RM_ZB_XLU_SURF2 = RM_ZB_XLU_SURF(2);
//enum G_RM_ZB_OPA_DECAL = RM_ZB_OPA_DECAL(1);
//enum G_RM_ZB_OPA_DECAL2 = RM_ZB_OPA_DECAL(2);
//enum G_RM_ZB_XLU_DECAL = RM_ZB_XLU_DECAL(1);
//enum G_RM_ZB_XLU_DECAL2 = RM_ZB_XLU_DECAL(2);
//enum G_RM_ZB_CLD_SURF = RM_ZB_CLD_SURF(1);
//enum G_RM_ZB_CLD_SURF2 = RM_ZB_CLD_SURF(2);
//enum G_RM_ZB_OVL_SURF = RM_ZB_OVL_SURF(1);
//enum G_RM_ZB_OVL_SURF2 = RM_ZB_OVL_SURF(2);
//enum G_RM_ZB_PCL_SURF = RM_ZB_PCL_SURF(1);
//enum G_RM_ZB_PCL_SURF2 = RM_ZB_PCL_SURF(2);

//enum G_RM_OPA_SURF = RM_OPA_SURF(1);
//enum G_RM_OPA_SURF2 = RM_OPA_SURF(2);
//enum G_RM_XLU_SURF = RM_XLU_SURF(1);
//enum G_RM_XLU_SURF2 = RM_XLU_SURF(2);
//enum G_RM_CLD_SURF = RM_CLD_SURF(1);
//enum G_RM_CLD_SURF2 = RM_CLD_SURF(2);
//enum G_RM_TEX_EDGE = RM_TEX_EDGE(1);
//enum G_RM_TEX_EDGE2 = RM_TEX_EDGE(2);
//enum G_RM_PCL_SURF = RM_PCL_SURF(1);
//enum G_RM_PCL_SURF2 = RM_PCL_SURF(2);
//enum G_RM_ADD = RM_ADD(1);
//enum G_RM_ADD2 = RM_ADD(2);
//enum G_RM_NOOP = RM_NOOP(1);
//enum G_RM_NOOP2 = RM_NOOP(2);
//enum G_RM_VISCVG = RM_VISCVG(1);
//enum G_RM_VISCVG2 = RM_VISCVG(2);
//enum G_RM_OPA_CI = RM_OPA_CI(1);
//enum G_RM_OPA_CI2 = RM_OPA_CI(2);

//enum G_RM_CUSTOM_AA_ZB_XLU_SURF = RM_CUSTOM_AA_ZB_XLU_SURF(1);
//enum G_RM_CUSTOM_AA_ZB_XLU_SURF2 = RM_CUSTOM_AA_ZB_XLU_SURF(2);

enum G_RM_FOG_SHADE_A = GBL_c1(G_BL_CLR_FOG, G_BL_A_SHADE, G_BL_CLR_IN, G_BL_1MA);
enum G_RM_FOG_PRIM_A = GBL_c1(G_BL_CLR_FOG, G_BL_A_FOG, G_BL_CLR_IN, G_BL_1MA);
enum G_RM_PASS = GBL_c1(G_BL_CLR_IN, G_BL_0, G_BL_CLR_IN, G_BL_1);

/*
 * G_SETCONVERT: K0-5
 */
enum G_CV_K0 = 175;
enum G_CV_K1 = -43;
enum G_CV_K2 = -89;
enum G_CV_K3 = 222;
enum G_CV_K4 = 114;
enum G_CV_K5 = 42;

/*
 * G_SETSCISSOR: interlace mode
 */
enum G_SC_NON_INTERLACE = 0;
enum G_SC_ODD_INTERLACE = 3;
enum G_SC_EVEN_INTERLACE = 2;

/* flags to inhibit pushing of the display list (on branch) */
enum G_DL_PUSH = 0x00;
enum G_DL_NOPUSH = 0x01;

/*
 * BEGIN C-specific section: (typedef's)
 */
// #if defined(_LANGUAGE_C) || defined(_LANGUAGE_C_PLUS_PLUS)

/*
 * Data Structures
 *
 * NOTE:
 * The DMA transfer hardware requires 64-bit aligned, 64-bit multiple-
 * sized transfers. This important hardware optimization is unfortunately
 * reflected in the programming interface, with some structures
 * padded and alignment enforced.
 *
 * Since structures are aligned to the boundary of the "worst-case"
 * element, we can't depend on the C compiler to align things
 * properly.
 *
 * 64-bit structure alignment is enforced by wrapping structures with
 * unions that contain a dummy "long long int".  Why this works is
 * explained in the ANSI C Spec, or on page 186 of the second edition
 * of K&R, "The C Programming Language".
 *
 * The price we pay for this is a little awkwardness referencing the
 * structures through the union. There is no memory penalty, since
 * all the structures are at least 64-bits the dummy alignment field
 * does not increase the size of the union.
 *
 * Static initialization of these union structures works because
 * the ANSI C spec states that static initialization for unions
 * works by using the first union element. We put the dummy alignment
 * field last for this reason.
 *
 * (it's possible a newer 64-bit compiler from MIPS might make this
 * easier with a flag, but we can't wait for it...)
 *
 */

/*
 * Vertex (set up for use with colors)
 */
struct Vtx_t
{
    /* x, y, z */

    float[3] ob; /* x, y, z */

    ushort flag;
    short[2] tc; /* texture coord */
    ubyte[4] cn; /* color & alpha */
}

/*
 * Vertex (set up for use with normals)
 */
struct Vtx_tn
{
    /* x, y, z */

    float[3] ob; /* x, y, z */

    ushort flag;
    short[2] tc; /* texture coord */
    byte[3] n; /* normal */
    ubyte a; /* alpha  */
}

union Vtx
{
    Vtx_t v; /* Use this one for colors  */
    Vtx_tn n; /* Use this one for normals */
    long force_structure_alignment;
}

/*
 * Sprite structure
 */

struct uSprite_t
{
    void* SourceImagePointer;
    void* TlutPointer;
    short Stride;
    short SubImageWidth;
    short SubImageHeight;
    char SourceImageType;
    char SourceImageBitSize;
    short SourceImageOffsetS;
    short SourceImageOffsetT;
    /* 20 bytes for above */

    /* padding to bring structure size to 64 bit allignment */
    char[4] dummy;
}

union uSprite
{
    uSprite_t s;

    /* Need to make sure this is 64 bit aligned */
    long[3] force_structure_allignment;
}

/*
 * Triangle face
 */
struct Tri
{
    ubyte flag;
    ubyte[3] v;
}

// #ifndef GBI_FLOATS
/*
 * 4x4 matrix, fixed point s15.16 format.
 * First 8 words are integer portion of the 4x4 matrix
 * Last 8 words are the fraction portion of the 4x4 matrix
 */
// typedef s32	Mtx_t[4][4];

// typedef union {
//     Mtx_t		m;
//     long long int	force_structure_alignment;
// } Mtx;
// #else
struct Mtx
{
    float[4][4] m;
}

// #endif

/*
 * Viewport
 */

/*
 *
 * This magic value is the maximum INTEGER z-range of the hardware
 * (there are also 16-bits of fraction, which are introduced during
 * any transformations). This is not just a good idea, it's the law.
 * Feeding the hardware eventual z-coordinates (after any transforms
 * or scaling) bigger than this, will not work.
 *
 * This number is DIFFERENT than G_MAXFBZ, which is the maximum value
 * you want to use to initialize the z-buffer.
 *
 * The reason these are different is mildly interesting, but too long
 * to explain here. It is basically the result of optimizations in the
 * hardware. A more generic API might hide this detail from the users,
 * but we don't have the ucode to do that...
 *
 */
enum G_MAXZ = 0x03ff; /* 10 bits of integer screen-Z precision */

/*
 * The viewport structure elements have 2 bits of fraction, necessary
 * to accomodate the sub-pixel positioning scaling for the hardware.
 * This can also be exploited to handle odd-sized viewports.
 *
 * Accounting for these fractional bits, using the default projection
 * and viewing matrices, the viewport structure is initialized thusly:
 *
 *		(SCREEN_WD/2)*4, (SCREEN_HT/2)*4, G_MAXZ, 0,
 *		(SCREEN_WD/2)*4, (SCREEN_HT/2)*4, 0, 0,
 */
struct Vp_t
{
    short[4] vscale; /* scale, 2 bits fraction */
    short[4] vtrans; /* translate, 2 bits fraction */
    /* both the above arrays are padded to 64-bit boundary */
}

union Vp
{
    Vp_t vp;
    long force_structure_alignment;
}

/*
 * MOVEMEM indices
 *
 * Each of these indexes an entry in a dmem table
 * which points to a 1-4 word block of dmem in
 * which to store a 1-4 word DMA.
 *
 */
/* 0,4 are reserved by G_MTX */
enum G_MV_MMTX = 2;
enum G_MV_PMTX = 6;
enum G_MV_VIEWPORT = 8;
enum G_MV_LIGHT = 10;
enum G_MV_POINT = 12;
enum G_MV_MATRIX = 14; /* NOTE: this is in moveword table */
enum G_MVO_LOOKATX = 0 * 24;
enum G_MVO_LOOKATY = 1 * 24;
enum G_MVO_L0 = 2 * 24;
enum G_MVO_L1 = 3 * 24;
enum G_MVO_L2 = 4 * 24;
enum G_MVO_L3 = 5 * 24;
enum G_MVO_L4 = 6 * 24;
enum G_MVO_L5 = 7 * 24;
enum G_MVO_L6 = 8 * 24;
enum G_MVO_L7 = 9 * 24;
/* F3DEX_GBI_2 */

/* NOTE: this is in moveword table */

/* F3DEX_GBI_2 */

/*
 * MOVEWORD indices
 *
 * Each of these indexes an entry in a dmem table
 * which points to a word in dmem in dmem where
 * an immediate word will be stored.
 *
 */
enum G_MW_MATRIX = 0x00; /* NOTE: also used by movemem */
enum G_MW_NUMLIGHT = 0x02;
enum G_MW_CLIP = 0x04;
enum G_MW_SEGMENT = 0x06;
enum G_MW_FOG = 0x08;
enum G_MW_LIGHTCOL = 0x0a;
enum G_MW_FORCEMTX = 0x0c;
/* F3DEX_GBI_2 */

/* F3DEX_GBI_2 */
enum G_MW_PERSPNORM = 0x0e;

/*
 * These are offsets from the address in the dmem table
 */
enum G_MWO_NUMLIGHT = 0x00;
enum G_MWO_CLIP_RNX = 0x04;
enum G_MWO_CLIP_RNY = 0x0c;
enum G_MWO_CLIP_RPX = 0x14;
enum G_MWO_CLIP_RPY = 0x1c;
enum G_MWO_SEGMENT_0 = 0x00;
enum G_MWO_SEGMENT_1 = 0x01;
enum G_MWO_SEGMENT_2 = 0x02;
enum G_MWO_SEGMENT_3 = 0x03;
enum G_MWO_SEGMENT_4 = 0x04;
enum G_MWO_SEGMENT_5 = 0x05;
enum G_MWO_SEGMENT_6 = 0x06;
enum G_MWO_SEGMENT_7 = 0x07;
enum G_MWO_SEGMENT_8 = 0x08;
enum G_MWO_SEGMENT_9 = 0x09;
enum G_MWO_SEGMENT_A = 0x0a;
enum G_MWO_SEGMENT_B = 0x0b;
enum G_MWO_SEGMENT_C = 0x0c;
enum G_MWO_SEGMENT_D = 0x0d;
enum G_MWO_SEGMENT_E = 0x0e;
enum G_MWO_SEGMENT_F = 0x0f;
enum G_MWO_FOG = 0x00;
enum G_MWO_aLIGHT_1 = 0x00;
enum G_MWO_bLIGHT_1 = 0x04;
enum G_MWO_aLIGHT_2 = 0x18;
enum G_MWO_bLIGHT_2 = 0x1c;
enum G_MWO_aLIGHT_3 = 0x30;
enum G_MWO_bLIGHT_3 = 0x34;
enum G_MWO_aLIGHT_4 = 0x48;
enum G_MWO_bLIGHT_4 = 0x4c;
enum G_MWO_aLIGHT_5 = 0x60;
enum G_MWO_bLIGHT_5 = 0x64;
enum G_MWO_aLIGHT_6 = 0x78;
enum G_MWO_bLIGHT_6 = 0x7c;
enum G_MWO_aLIGHT_7 = 0x90;
enum G_MWO_bLIGHT_7 = 0x94;
enum G_MWO_aLIGHT_8 = 0xa8;
enum G_MWO_bLIGHT_8 = 0xac;

enum G_MWO_MATRIX_XX_XY_I = 0x00;
enum G_MWO_MATRIX_XZ_XW_I = 0x04;
enum G_MWO_MATRIX_YX_YY_I = 0x08;
enum G_MWO_MATRIX_YZ_YW_I = 0x0c;
enum G_MWO_MATRIX_ZX_ZY_I = 0x10;
enum G_MWO_MATRIX_ZZ_ZW_I = 0x14;
enum G_MWO_MATRIX_WX_WY_I = 0x18;
enum G_MWO_MATRIX_WZ_WW_I = 0x1c;
enum G_MWO_MATRIX_XX_XY_F = 0x20;
enum G_MWO_MATRIX_XZ_XW_F = 0x24;
enum G_MWO_MATRIX_YX_YY_F = 0x28;
enum G_MWO_MATRIX_YZ_YW_F = 0x2c;
enum G_MWO_MATRIX_ZX_ZY_F = 0x30;
enum G_MWO_MATRIX_ZZ_ZW_F = 0x34;
enum G_MWO_MATRIX_WX_WY_F = 0x38;
enum G_MWO_MATRIX_WZ_WW_F = 0x3c;
enum G_MWO_POINT_RGBA = 0x10;
enum G_MWO_POINT_ST = 0x14;
enum G_MWO_POINT_XYSCREEN = 0x18;
enum G_MWO_POINT_ZSCREEN = 0x1c;

/*
 * Light structure.
 *
 * Note: only directional (infinite) lights are currently supported.
 *
 * Note: the weird order is for the DMEM alignment benefit of
 * the microcode.
 *
 */

struct Light_t
{
    ubyte[3] col; /* diffuse light value (rgba) */
    char pad1;
    ubyte[3] colc; /* copy of diffuse light value (rgba) */
    char pad2;
    byte[3] dir; /* direction of light (normalized) */
    char pad3;
}

struct Ambient_t
{
    ubyte[3] col; /* ambient light value (rgba) */
    char pad1;
    ubyte[3] colc; /* copy of ambient light value (rgba) */
    char pad2;
}

struct Hilite_t
{
    int x1;
    int y1;
    int x2;
    int y2; /* texture offsets for highlight 1/2 */
}

union Light
{
    Light_t l;
    long[2] force_structure_alignment;
}

union Ambient
{
    Ambient_t l;
    long[1] force_structure_alignment;
}

struct Lightsn
{
    Ambient a;
    Light[7] l;
}

struct Lights0
{
    Ambient a;
    Light[1] l;
}

struct Lights1
{
    Ambient a;
    Light[1] l;
}

struct Lights2
{
    Ambient a;
    Light[2] l;
}

struct Lights3
{
    Ambient a;
    Light[3] l;
}

struct Lights4
{
    Ambient a;
    Light[4] l;
}

struct Lights5
{
    Ambient a;
    Light[5] l;
}

struct Lights6
{
    Ambient a;
    Light[6] l;
}

struct Lights7
{
    Ambient a;
    Light[7] l;
}

struct LookAt
{
    Light[2] l;
}

union Hilite
{
    Hilite_t h;
    c_long[4] force_structure_alignment;
}

/* Don't declare these for F3D_OLD to avoid bss reordering */

/*
 *  Graphics DMA Packet
 */
struct Gdma
{
    import std.bitmanip : bitfields;

    mixin(bitfields!(
        int, "cmd", 8,
        uint, "par", 8,
        uint, "len", 16));

    uintptr_t addr;
}

/*
 * Graphics Immediate Mode Packet types
 */
struct Gtri
{
    import std.bitmanip : bitfields;

    mixin(bitfields!(
        int, "cmd", 8,
        int, "pad", 24));

    Tri tri;
}

struct Gpopmtx
{
    import std.bitmanip : bitfields;

    mixin(bitfields!(
        int, "cmd", 8,
        int, "pad1", 24,
        int, "pad2", 24,
        ubyte, "param", 8));
}

/*
 * typedef struct {
 * 		int		cmd:8;
 * 		int		pad0:24;
 * 		int		pad1:4;
 * 		int		number:4;
 * 		int		base:24;
 * } Gsegment;
 */
struct Gsegment
{
    import std.bitmanip : bitfields;

    mixin(bitfields!(
        int, "cmd", 8,
        int, "pad0", 8,
        int, "mw_index", 8,
        int, "number", 8,
        int, "pad1", 8,
        int, "base", 24));
}

struct GsetothermodeL
{
    import std.bitmanip : bitfields;

    mixin(bitfields!(
        int, "cmd", 8,
        int, "pad0", 8,
        int, "sft", 8,
        int, "len", 8,
        uint, "data", 32));
}

struct GsetothermodeH
{
    import std.bitmanip : bitfields;

    mixin(bitfields!(
        int, "cmd", 8,
        int, "pad0", 8,
        int, "sft", 8,
        int, "len", 8,
        uint, "data", 32));
}

struct Gtexture
{
    ubyte cmd;
    ubyte lodscale;
    ubyte tile;
    ubyte on;
    ushort s;
    ushort t;
}

struct Gline3D
{
    import std.bitmanip : bitfields;

    mixin(bitfields!(
        int, "cmd", 8,
        int, "pad", 24));

    Tri line;
}

struct Gperspnorm
{
    import std.bitmanip : bitfields;

    mixin(bitfields!(
        int, "cmd", 8,
        int, "pad1", 24));

    short pad2;
    short scale;
}

/*
 * RDP Packet types
 */
struct Gsetimg
{
    import std.bitmanip : bitfields;

    mixin(bitfields!(
        int, "cmd", 8,
        uint, "fmt", 3,
        uint, "siz", 2,
        uint, "pad", 7,
        uint, "wd", 12));

    /* really only 10 bits, extra	*/
    uintptr_t dram; /* to account for 1024		*/
}

struct Gsetcombine
{
    import std.bitmanip : bitfields;

    mixin(bitfields!(
        int, "cmd", 8,
        uint, "muxs0", 24,
        uint, "muxs1", 32));
}

struct Gsetcolor
{
    import std.bitmanip : bitfields;
    mixin(bitfields!(int, "cmd", 8));

    ubyte pad;
    ubyte prim_min_level;
    ubyte prim_level;
    c_ulong color;
}

struct Gfillrect
{
    import std.bitmanip : bitfields;

    mixin(bitfields!(
        int, "cmd", 8,
        int, "x0", 10,
        int, "x0frac", 2,
        int, "y0", 10,
        int, "y0frac", 2,
        uint, "pad", 8,
        int, "x1", 10,
        int, "x1frac", 2,
        int, "y1", 10,
        int, "y1frac", 2));
}

struct Gsettile
{
    import std.bitmanip : bitfields;

    mixin(bitfields!(
        int, "cmd", 8,
        uint, "fmt", 3,
        uint, "siz", 2,
        uint, "pad0", 1,
        uint, "line", 9,
        uint, "tmem", 9,
        uint, "pad1", 5,
        uint, "tile", 3,
        uint, "palette", 4,
        uint, "ct", 1,
        uint, "mt", 1,
        uint, "maskt", 4,
        uint, "shiftt", 4,
        uint, "cs", 1,
        uint, "ms", 1,
        uint, "masks", 4,
        uint, "shifts", 4));
}

struct Gloadtile
{
    import std.bitmanip : bitfields;

    mixin(bitfields!(
        int, "cmd", 8,
        uint, "sl", 12,
        uint, "tl", 12,
        int, "pad", 5,
        uint, "tile", 3,
        uint, "sh", 12,
        uint, "th", 12));
}

alias Gloadblock = Gloadtile;

alias Gsettilesize = Gloadtile;

alias Gloadtlut = Gloadtile;

struct Gtexrect
{
    import std.bitmanip : bitfields;

    mixin(bitfields!(
        uint, "cmd", 8,
        uint, "xl", 12,
        uint, "yl", 12,
        uint, "pad1", 5,
        uint, "tile", 3,
        uint, "xh", 12,
        uint, "yh", 12));
    mixin(bitfields!(
        uint, "s", 16,
        uint, "t", 16,
        uint, "dsdx", 16,
        uint, "dtdy", 16));

    /* command			*/
    /* X coordinate of upper left	*/
    /* Y coordinate of upper left	*/
    /* Padding			*/
    /* Tile descriptor index	*/
    /* X coordinate of lower right	*/
    /* Y coordinate of lower right	*/
    /* S texture coord at top left	*/
    /* T texture coord at top left	*/
    /* Change in S per change in X	*/
    /* Change in T per change in Y	*/
}

/*
 * Textured rectangles are 128 bits not 64 bits
 */
struct TexRect
{
    c_ulong w0;
    c_ulong w1;
    c_ulong w2;
    c_ulong w3;
}

/*
 * Generic Gfx Packet
 */
struct Gwords
{
    uintptr_t w0;
    uintptr_t w1;
}

/*
 * This union is the fundamental type of the display list.
 * It is, by law, exactly 64 bits in size.
 *
 * (Edit: except on 64-bit, where it is exactly 128 bit. On little-endian or
 * 64-bit systems, only the 'words' member may be accessed; the rest of the
 * structs don't have matching layouts for now.)
 */
union Gfx
{
    Gwords words;

    /* use for setscissor also */

    /* use for loadblock also, th is dxt */

    long force_structure_alignment;
}

/*
 * Macros to assemble the graphics display list
 */

/*
 * DMA macros
 */

//@@@ D conversion - todo: fix
//extern (D) auto gSPNoOp(T)(auto ref T pkt)
//{
//    return gDma0p(pkt, G_SPNOOP, 0, 0);
//}

//extern (D) auto gsSPNoOp()
//{
//    return gsDma0p(G_SPNOOP, 0, 0);
//}

/* F3DEX_GBI_2 */

/* F3DEX_GBI_2 */

/*
 * F3DEX_GBI_2: G_VTX GBI format was changed.
 *
 *        +--------+----+---+---+----+------+-+
 *  G_VTX |  cmd:8 |0000|  n:8  |0000|v0+n:7|0|
 *        +-+---+--+----+---+---+----+------+-+
 *        | |seg|         address             |
 *        +-+---+-----------------------------+
 */

/*
 * F3DEX_GBI: G_VTX GBI format was changed to support 64 vertice.
 *
 *        +--------+--------+------+----------+
 *  G_VTX |  cmd:8 |  v0:8  |  n:6 |length:10 |
 *        +-+---+--+--------+------+----------+
 *        | |seg|          address            |
 *        +-+---+-----------------------------+
 */

extern (D) auto gSPViewport(T0, T1)(auto ref T0 pkt, auto ref T1 v)
{
    return gDma2p(pkt, G_MOVEMEM, v, Vp.sizeof, G_MV_VIEWPORT, 0);
}

extern (D) auto gsSPViewport(T)(auto ref T v)
{
    return gsDma2p(G_MOVEMEM, v, Vp.sizeof, G_MV_VIEWPORT, 0);
}

/* F3DEX_GBI_2 */

/* F3DEX_GBI_2 */

extern (D) auto gSPDisplayList(T0, T1)(auto ref T0 pkt, auto ref T1 dl)
{
    return gDma1p(pkt, G_DL, dl, 0, G_DL_PUSH);
}

extern (D) auto gsSPDisplayList(T)(auto ref T dl)
{
    return gsDma1p(G_DL, dl, 0, G_DL_PUSH);
}

extern (D) auto gSPBranchList(T0, T1)(auto ref T0 pkt, auto ref T1 dl)
{
    return gDma1p(pkt, G_DL, dl, 0, G_DL_NOPUSH);
}

extern (D) auto gsSPBranchList(T)(auto ref T dl)
{
    return gsDma1p(G_DL, dl, 0, G_DL_NOPUSH);
}

extern (D) auto gSPSprite2DBase(T0, T1)(auto ref T0 pkt, auto ref T1 s)
{
    return gDma1p(pkt, G_SPRITE2D_BASE, s, uSprite.sizeof, 0);
}

extern (D) auto gsSPSprite2DBase(T)(auto ref T s)
{
    return gsDma1p(G_SPRITE2D_BASE, s, uSprite.sizeof, 0);
}

/*
 * RSP short command (no DMA required) macros
 */

extern (D) auto gMoveWd(T0, T1, T2, T3)(auto ref T0 pkt, auto ref T1 index, auto ref T2 offset, auto ref T3 data)
{
    return gDma1p(pkt, G_MOVEWORD, data, offset, index);
}

extern (D) auto gsMoveWd(T0, T1, T2)(auto ref T0 index, auto ref T1 offset, auto ref T2 data)
{
    return gsDma1p(G_MOVEWORD, data, offset, index);
}

/* F3DEX_GBI_2 */

/* F3DEX_GBI_2 */

/* Sprite immediate macros, there is also a sprite dma macro above */

/*
 * Note: the SP1Triangle() and line macros multiply the vertex indices
 * by 10, this is an optimization for the microcode.
 */
extern (D) auto __gsSP1Triangle_w1(T0, T1, T2)(auto ref T0 v0, auto ref T1 v1, auto ref T2 v2)
{
    return _SHIFTL(v0 * 2, 16, 8) | _SHIFTL(v1 * 2, 8, 8) | _SHIFTL(v2 * 2, 0, 8);
}

extern (D) auto __gsSP1Triangle_w1f(T0, T1, T2, T3)(auto ref T0 v0, auto ref T1 v1, auto ref T2 v2, auto ref T3 flag)
{
    return (flag == 0) ? __gsSP1Triangle_w1(v0, v1, v2) : (flag == 1) ? __gsSP1Triangle_w1(v1, v2, v0) : __gsSP1Triangle_w1(v2, v0, v1);
}

extern (D) auto __gsSPLine3D_w1(T0, T1, T2)(auto ref T0 v0, auto ref T1 v1, auto ref T2 wd)
{
    return _SHIFTL(v0 * 2, 16, 8) | _SHIFT(v1 * 2, 8, 8) | _SHIFT(wd, 0, 8);
}

extern (D) auto __gsSPLine3D_w1f(T0, T1, T2, T3)(auto ref T0 v0, auto ref T1 v1, auto ref T2 wd, auto ref T3 flag)
{
    return (flag == 0) ? __gsSPLine3D_w1(v0, v1, wd) : __gsSPLine3D_w1(v1, v0, wd);
}

extern (D) auto __gsSP1Quadrangle_w1f(T0, T1, T2, T3, T4)(auto ref T0 v0, auto ref T1 v1, auto ref T2 v2, auto ref T3 v3, auto ref T4 flag)
{
    return (flag == 0) ? __gsSP1Triangle_w1(v0, v1, v2) : (flag == 1) ? __gsSP1Triangle_w1(v1, v2, v3) : (flag == 2) ? __gsSP1Triangle_w1(v2, v3, v0) : __gsSP1Triangle_w1(v3, v0, v1);
}

extern (D) auto __gsSP1Quadrangle_w2f(T0, T1, T2, T3, T4)(auto ref T0 v0, auto ref T1 v1, auto ref T2 v2, auto ref T3 v3, auto ref T4 flag)
{
    return (flag == 0) ? __gsSP1Triangle_w1(v0, v2, v3) : (flag == 1) ? __gsSP1Triangle_w1(v1, v3, v0) : (flag == 2) ? __gsSP1Triangle_w1(v2, v0, v1) : __gsSP1Triangle_w1(v3, v1, v2);
}

/***
 ***  1 Triangle
 ***/

/***
 ***  Line
 ***/

/***
 ***  LineW
 ***/
/* these macros are the same as SPLine3D, except they have an
 * additional parameter for width. The width is added to the "minimum"
 * thickness, which is 1.5 pixels. The units for width are in
 * half-pixel units, so a width of 1 translates to (.5 + 1.5) or
 * a 2.0 pixels wide line.
 */

/***
 ***  1 Quadrangle
 ***/

/* F3DEX_GBI_2 */

/***
 ***  1 Triangle
 ***/

/***
 ***  Line
 ***/

/***
 ***  LineW
 ***/
/* these macros are the same as SPLine3D, except they have an
 * additional parameter for width. The width is added to the "minimum"
 * thickness, which is 1.5 pixels. The units for width are in
 * half-pixel units, so a width of 1 translates to (.5 + 1.5) or
 * a 2.0 pixels wide line.
 */

/***
 ***  1 Quadrangle
 ***/

/* F3DEX_GBI_2 */

/***
 ***  2 Triangles
 ***/

/* F3DEX_GBI/F3DLP_GBI */

extern (D) auto gSPSegment(T0, T1, T2)(auto ref T0 pkt, auto ref T1 segment, auto ref T2 base)
{
    return gMoveWd(pkt, G_MW_SEGMENT, segment * 4, base);
}

extern (D) auto gsSPSegment(T0, T1)(auto ref T0 segment, auto ref T1 base)
{
    return gsMoveWd(G_MW_SEGMENT, segment * 4, base);
}

/*
 * Clipping Macros
 */
enum FR_NEG_FRUSTRATIO_1 = 0x00000001;
enum FR_POS_FRUSTRATIO_1 = 0x0000ffff;
enum FR_NEG_FRUSTRATIO_2 = 0x00000002;
enum FR_POS_FRUSTRATIO_2 = 0x0000fffe;
enum FR_NEG_FRUSTRATIO_3 = 0x00000003;
enum FR_POS_FRUSTRATIO_3 = 0x0000fffd;
enum FR_NEG_FRUSTRATIO_4 = 0x00000004;
enum FR_POS_FRUSTRATIO_4 = 0x0000fffc;
enum FR_NEG_FRUSTRATIO_5 = 0x00000005;
enum FR_POS_FRUSTRATIO_5 = 0x0000fffb;
enum FR_NEG_FRUSTRATIO_6 = 0x00000006;
enum FR_POS_FRUSTRATIO_6 = 0x0000fffa;
/*
 * r should be one of: FRUSTRATIO_1, FRUSTRATIO_2, FRUSTRATIO_3, ... FRUSTRATIO_6
 */

/*
 * Insert values into Matrix
 *
 * where = element of matrix (byte offset)
 * num   = new element (32 bit value replacing 2 int or 2 frac matrix
 *                                 componants
 */

/*
 * Load new matrix directly
 *
 * mptr = pointer to matrix
 */

/* F3DEX_GBI_2 */

/* F3DEX_GBI_2 */

/*
 * Insert values into Points
 *
 * point = point number 0-15
 * where = which element of point to modify (byte offset into point)
 * num   = new value (32 bit)
 */

/*
 *  gSPBranchLessZ   Branch DL if (vtx.z) less than or equal (zval).
 *
 *  dl	 = DL branch to
 *  vtx  = Vertex
 *  zval = Screen depth
 *  near = Near plane
 *  far  = Far  plane
 *  flag = G_BZ_PERSP or G_BZ_ORTHO
 */

enum G_BZ_PERSP = 0;
enum G_BZ_ORTHO = 1;

extern (D) auto G_DEPTOZS(T0, T1, T2, T3)(auto ref T0 zval, auto ref T1 near, auto ref T2 far, auto ref T3 flag)
{
    return G_DEPTOZSrg(zval, near, far, flag, 0, G_MAXZ);
}

extern (D) auto gSPBranchLessZ(T0, T1, T2, T3, T4, T5, T6)(auto ref T0 pkt, auto ref T1 dl, auto ref T2 vtx, auto ref T3 zval, auto ref T4 near, auto ref T5 far, auto ref T6 flag)
{
    return gSPBranchLessZrg(pkt, dl, vtx, zval, near, far, flag, 0, G_MAXZ);
}

extern (D) auto gsSPBranchLessZ(T0, T1, T2, T3, T4, T5)(auto ref T0 dl, auto ref T1 vtx, auto ref T2 zval, auto ref T3 near, auto ref T4 far, auto ref T5 flag)
{
    return gsSPBranchLessZrg(dl, vtx, zval, near, far, flag, 0, G_MAXZ);
}

/*
 *  gSPBranchLessZraw   Branch DL if (vtx.z) less than or equal (raw zval).
 *
 *  dl	 = DL branch to
 *  vtx  = Vertex
 *  zval = Raw value of screen depth
 */

/*
 * gSPLoadUcode   RSP loads specified ucode.
 *
 * uc_start  = ucode text section start
 * uc_dstart = ucode data section start
 */

extern (D) auto gSPLoadUcode(T0, T1, T2)(auto ref T0 pkt, auto ref T1 uc_start, auto ref T2 uc_dstart)
{
    return gSPLoadUcodeEx(pkt, uc_start, uc_dstart, SP_UCODE_DATA_SIZE);
}

extern (D) auto gsSPLoadUcode(T0, T1)(auto ref T0 uc_start, auto ref T1 uc_dstart)
{
    return gsSPLoadUcodeEx(uc_start, uc_dstart, SP_UCODE_DATA_SIZE);
}

/*
 * gSPDma_io  DMA to/from DMEM/IMEM for DEBUG.
 */

extern (D) auto gSPDmaRead(T0, T1, T2, T3)(auto ref T0 pkt, auto ref T1 dmem, auto ref T2 dram, auto ref T3 size)
{
    return gSPDma_io(pkt, 0, dmem, dram, size);
}

extern (D) auto gsSPDmaRead(T0, T1, T2)(auto ref T0 dmem, auto ref T1 dram, auto ref T2 size)
{
    return gsSPDma_io(0, dmem, dram, size);
}

extern (D) auto gSPDmaWrite(T0, T1, T2, T3)(auto ref T0 pkt, auto ref T1 dmem, auto ref T2 dram, auto ref T3 size)
{
    return gSPDma_io(pkt, 1, dmem, dram, size);
}

extern (D) auto gsSPDmaWrite(T0, T1, T2)(auto ref T0 dmem, auto ref T1 dram, auto ref T2 size)
{
    return gsSPDma_io(1, dmem, dram, size);
}

/*
 * Lighting Macros
 */
extern (D) auto NUML(T)(auto ref T n)
{
    return n * 24;
}

enum NUMLIGHTS_0 = 1;
enum NUMLIGHTS_1 = 1;
enum NUMLIGHTS_2 = 2;
enum NUMLIGHTS_3 = 3;
enum NUMLIGHTS_4 = 4;
enum NUMLIGHTS_5 = 5;
enum NUMLIGHTS_6 = 6;
enum NUMLIGHTS_7 = 7;
/*
 * n should be one of: NUMLIGHTS_0, NUMLIGHTS_1, ..., NUMLIGHTS_7
 * NOTE: in addition to the number of directional lights specified,
 *       there is always 1 ambient light
 */
extern (D) auto gSPNumLights(T0, T1)(auto ref T0 pkt, auto ref T1 n)
{
    return gMoveWd(pkt, G_MW_NUMLIGHT, G_MWO_NUMLIGHT, NUML(n));
}

extern (D) auto gsSPNumLights(T)(auto ref T n)
{
    return gsMoveWd(G_MW_NUMLIGHT, G_MWO_NUMLIGHT, NUML(n));
}

enum LIGHT_1 = 1;
enum LIGHT_2 = 2;
enum LIGHT_3 = 3;
enum LIGHT_4 = 4;
enum LIGHT_5 = 5;
enum LIGHT_6 = 6;
enum LIGHT_7 = 7;
enum LIGHT_8 = 8;
/*
 * l should point to a Light struct
 * n should be one of: LIGHT_1, LIGHT_2, ..., LIGHT_8
 * NOTE: the highest numbered light is always the ambient light (eg if there are
 *       3 directional lights defined: gsSPNumLights(NUMLIGHTS_3), then lights
 *       LIGHT_1 through LIGHT_3 will be the directional lights and light
 *       LIGHT_4 will be the ambient light.
 */
extern (D) auto gSPLight(T0, T1, T2)(auto ref T0 pkt, auto ref T1 l, auto ref T2 n)
{
    return gDma2p(pkt, G_MOVEMEM, l, Light.sizeof, G_MV_LIGHT, n * 24 + 24);
}

extern (D) auto gsSPLight(T0, T1)(auto ref T0 l, auto ref T1 n)
{
    return gsDma2p(G_MOVEMEM, l, Light.sizeof, G_MV_LIGHT, n * 24 + 24);
}

/* F3DEX_GBI_2 */

/* F3DEX_GBI_2 */

/*
 * gSPLightColor changes color of light without recalculating light direction
 * col is a 32 bit word with r,g,b,a (alpha is ignored)
 * n should be one of LIGHT_1, LIGHT_2, ..., LIGHT_8
 */

/* These macros use a structure "name" which is init'd with the gdSPDefLights macros*/

/*
 * Reflection/Hiliting Macros
 */
extern (D) auto gSPLookAtX(T0, T1)(auto ref T0 pkt, auto ref T1 l)
{
    return gDma2p(pkt, G_MOVEMEM, l, Light.sizeof, G_MV_LIGHT, G_MVO_LOOKATX);
}

extern (D) auto gsSPLookAtX(T)(auto ref T l)
{
    return gsDma2p(G_MOVEMEM, l, Light.sizeof, G_MV_LIGHT, G_MVO_LOOKATX);
}

extern (D) auto gSPLookAtY(T0, T1)(auto ref T0 pkt, auto ref T1 l)
{
    return gDma2p(pkt, G_MOVEMEM, l, Light.sizeof, G_MV_LIGHT, G_MVO_LOOKATY);
}

extern (D) auto gsSPLookAtY(T)(auto ref T l)
{
    return gsDma2p(G_MOVEMEM, l, Light.sizeof, G_MV_LIGHT, G_MVO_LOOKATY);
}

/* F3DEX_GBI_2 */

/* F3DEX_GBI_2 */

/*
 * FOG macros
 * fm = z multiplier
 * fo = z offset
 * FOG FORMULA:    alpha(fog) = (eyespace z) * fm  + fo  CLAMPED 0 to 255
 *   note: (eyespace z) ranges -1 to 1
 *
 * Alternate method of setting fog:
 * min, max: range 0 to 1000: 0=nearplane, 1000=farplane
 * min is where fog begins (usually less than max and often 0)
 * max is where fog is thickest (usually 1000)
 *
 */
extern (D) auto gSPFogFactor(T0, T1, T2)(auto ref T0 pkt, auto ref T1 fm, auto ref T2 fo)
{
    return gMoveWd(pkt, G_MW_FOG, G_MWO_FOG, _SHIFTL(fm, 16, 16) | _SHIFTL(fo, 0, 16));
}

extern (D) auto gsSPFogFactor(T0, T1)(auto ref T0 fm, auto ref T1 fo)
{
    return gsMoveWd(G_MW_FOG, G_MWO_FOG, _SHIFTL(fm, 16, 16) | _SHIFTL(fo, 0, 16));
}

extern (D) auto gSPFogPosition(T0, T1, T2)(auto ref T0 pkt, auto ref T1 min, auto ref T2 max)
{
    return gMoveWd(pkt, G_MW_FOG, G_MWO_FOG, _SHIFTL(128000 / (max - min), 16, 16) | _SHIFTL((500 - min) * 256 / (max - min), 0, 16));
}

extern (D) auto gsSPFogPosition(T0, T1)(auto ref T0 min, auto ref T1 max)
{
    return gsMoveWd(G_MW_FOG, G_MWO_FOG, _SHIFTL(128000 / (max - min), 16, 16) | _SHIFTL((500 - min) * 256 / (max - min), 0, 16));
}

/*
 * Macros to turn texture on/off
 */
/*
 * Different version of SPTexture macro, has an additional parameter
 * which is currently reserved in the microcode.
 */

/*
 * Macros to turn texture on/off
 */

/*
 * Different version of SPTexture macro, has an additional parameter
 * which is currently reserved in the microcode.
 */

extern (D) auto gSPPerspNormalize(T0, T1)(auto ref T0 pkt, auto ref T1 s)
{
    return gMoveWd(pkt, G_MW_PERSPNORM, 0, s);
}

extern (D) auto gsSPPerspNormalize(T)(auto ref T s)
{
    return gsMoveWd(G_MW_PERSPNORM, 0, s);
}

extern (D) auto gSPPopMatrixN(T0, T1, T2)(auto ref T0 pkt, auto ref T1 n, auto ref T2 num)
{
    return gDma2p(pkt, G_POPMTX, num * 64, 64, 2, 0);
}

extern (D) auto gsSPPopMatrixN(T0, T1)(auto ref T0 n, auto ref T1 num)
{
    return gsDma2p(G_POPMTX, num * 64, 64, 2, 0);
}

extern (D) auto gSPPopMatrix(T0, T1)(auto ref T0 pkt, auto ref T1 n)
{
    return gSPPopMatrixN(pkt, n, 1);
}

extern (D) auto gsSPPopMatrix(T)(auto ref T n)
{
    return gsSPPopMatrixN(n, 1);
}

/* F3DEX_GBI_2 */

/* F3DEX_GBI_2 */

extern (D) void gSPEndDisplayList(void* pkt)
{
    Gfx* _g = cast(Gfx*) pkt;

    _g.words.w0 = _SHIFTL(G_ENDDL, 24, 8);
    _g.words.w1 = 0;
}

/*
 *	One gSPGeometryMode(pkt,c,s) GBI is equal to these two GBIs.
 *
 *		gSPClearGeometryMode(pkt,c)
 *		gSPSetGeometryMode(pkt,s)
 *
 *	gSPLoadGeometryMode(pkt, word) sets GeometryMode directly.
 */
extern (D) void gSPGeometryMode(T)(void* pkt, T c, T s)
{
    Gfx* _g = cast(Gfx*) pkt;
    _g.words.w0 = _SHIFTL(G_GEOMETRYMODE,24,8)|_SHIFTL(~cast(u32)(c),0,24);
    _g.words.w1 = cast(u32) s;
}

//@@@ D conversion - todo: fix
//extern (D) auto gsSPGeometryMode(T0, T1)(auto ref T0 c, auto ref T1 s)
//{
//    (_SHIFTL(G_GEOMETRYMODE,24,8)|_SHIFTL(~cast(u32)(c),0,24));
//    return cast(u32)(s);
//}

extern (D) void gSPSetGeometryMode(T0, T1)(auto ref T0 pkt, auto ref T1 word)
{
    gSPGeometryMode(pkt, 0, word);
}

//extern (D) auto gsSPSetGeometryMode(T)(auto ref T word)
//{
//    return gsSPGeometryMode(0, word);
//}

extern (D) void gSPClearGeometryMode(T0, T1)(auto ref T0 pkt, auto ref T1 word)
{
    gSPGeometryMode(pkt, word, 0);
}

//extern (D) auto gsSPClearGeometryMode(T)(auto ref T word)
//{
//    return gsSPGeometryMode(word, 0);
//}

extern (D) void gSPLoadGeometryMode(T0, T1)(auto ref T0 pkt, auto ref T1 word)
{
    gSPGeometryMode(pkt, -1, word);
}

//extern (D) auto gsSPLoadGeometryMode(T)(auto ref T word)
//{
//    return gsSPGeometryMode(-1, word);
//}

//@@@ D conversion - todo: fix
//alias gsSPGeometryModeSetFirst = gsSPGeometryMode;
/* F3DEX_GBI_2 */

/*
 * gsSPGeometryMode
 * In Fast3DEX2 it is better to use this, as the RSP geometry mode
 * is able to be set and cleared in a single command.
 */

/* F3DEX_GBI_2 */
extern (D) void gSPSetOtherMode(T)(void* pkt, T cmd, T sft, T len, T data)
{
    Gfx* _g = cast(Gfx*)(pkt);
    _g.words.w0 = (_SHIFTL(cmd,24,8)|_SHIFTL(32-(sft)-(len),8,8)|
            _SHIFTL((len)-1,0,8));
    _g.words.w1 = cast(uint)(data);
}

/*
 * RDP setothermode register commands - register shadowed in RSP
 */
extern (D) auto gDPPipelineMode(T0, T1)(auto ref T0 pkt, auto ref T1 mode)
{
    gSPSetOtherMode(pkt, G_SETOTHERMODE_H, G_MDSFT_PIPELINE, 1, mode);
}

extern (D) auto gsDPPipelineMode(T)(auto ref T mode)
{
    return gsSPSetOtherMode(G_SETOTHERMODE_H, G_MDSFT_PIPELINE, 1, mode);
}

extern (D) auto gDPSetCycleType(T0, T1)(auto ref T0 pkt, auto ref T1 type)
{
    gSPSetOtherMode(pkt, G_SETOTHERMODE_H, G_MDSFT_CYCLETYPE, 2, type);
}

extern (D) auto gsDPSetCycleType(T)(auto ref T type)
{
    return gsSPSetOtherMode(G_SETOTHERMODE_H, G_MDSFT_CYCLETYPE, 2, type);
}

extern (D) auto gDPSetTexturePersp(T0, T1)(auto ref T0 pkt, auto ref T1 type)
{
    gSPSetOtherMode(pkt, G_SETOTHERMODE_H, G_MDSFT_TEXTPERSP, 1, type);
}

extern (D) auto gsDPSetTexturePersp(T)(auto ref T type)
{
    return gsSPSetOtherMode(G_SETOTHERMODE_H, G_MDSFT_TEXTPERSP, 1, type);
}

extern (D) auto gDPSetTextureDetail(T0, T1)(auto ref T0 pkt, auto ref T1 type)
{
    gSPSetOtherMode(pkt, G_SETOTHERMODE_H, G_MDSFT_TEXTDETAIL, 2, type);
}

extern (D) auto gsDPSetTextureDetail(T)(auto ref T type)
{
    return gsSPSetOtherMode(G_SETOTHERMODE_H, G_MDSFT_TEXTDETAIL, 2, type);
}

extern (D) auto gDPSetTextureLOD(T0, T1)(auto ref T0 pkt, auto ref T1 type)
{
    gSPSetOtherMode(pkt, G_SETOTHERMODE_H, G_MDSFT_TEXTLOD, 1, type);
}

extern (D) auto gsDPSetTextureLOD(T)(auto ref T type)
{
    return gsSPSetOtherMode(G_SETOTHERMODE_H, G_MDSFT_TEXTLOD, 1, type);
}

extern (D) auto gDPSetTextureLUT(T0, T1)(auto ref T0 pkt, auto ref T1 type)
{
    gSPSetOtherMode(pkt, G_SETOTHERMODE_H, G_MDSFT_TEXTLUT, 2, type);
}

extern (D) auto gsDPSetTextureLUT(T)(auto ref T type)
{
    return gsSPSetOtherMode(G_SETOTHERMODE_H, G_MDSFT_TEXTLUT, 2, type);
}

extern (D) auto gDPSetTextureFilter(T0, T1)(auto ref T0 pkt, auto ref T1 type)
{
    gSPSetOtherMode(pkt, G_SETOTHERMODE_H, G_MDSFT_TEXTFILT, 2, type);
}

extern (D) auto gsDPSetTextureFilter(T)(auto ref T type)
{
    return gsSPSetOtherMode(G_SETOTHERMODE_H, G_MDSFT_TEXTFILT, 2, type);
}

extern (D) auto gDPSetTextureConvert(T0, T1)(auto ref T0 pkt, auto ref T1 type)
{
    gSPSetOtherMode(pkt, G_SETOTHERMODE_H, G_MDSFT_TEXTCONV, 3, type);
}

extern (D) auto gsDPSetTextureConvert(T)(auto ref T type)
{
    return gsSPSetOtherMode(G_SETOTHERMODE_H, G_MDSFT_TEXTCONV, 3, type);
}

extern (D) auto gDPSetCombineKey(T0, T1)(auto ref T0 pkt, auto ref T1 type)
{
    gSPSetOtherMode(pkt, G_SETOTHERMODE_H, G_MDSFT_COMBKEY, 1, type);
}

extern (D) auto gsDPSetCombineKey(T)(auto ref T type)
{
    return gsSPSetOtherMode(G_SETOTHERMODE_H, G_MDSFT_COMBKEY, 1, type);
}

extern (D) auto gDPSetColorDither(T0, T1)(auto ref T0 pkt, auto ref T1 mode)
{
    gSPSetOtherMode(pkt, G_SETOTHERMODE_H, G_MDSFT_RGBDITHER, 2, mode);
}

extern (D) auto gsDPSetColorDither(T)(auto ref T mode)
{
    return gsSPSetOtherMode(G_SETOTHERMODE_H, G_MDSFT_RGBDITHER, 2, mode);
}

extern (D) auto gDPSetAlphaDither(T0, T1)(auto ref T0 pkt, auto ref T1 mode)
{
    gSPSetOtherMode(pkt, G_SETOTHERMODE_H, G_MDSFT_ALPHADITHER, 2, mode);
}

extern (D) auto gsDPSetAlphaDither(T)(auto ref T mode)
{
    return gsSPSetOtherMode(G_SETOTHERMODE_H, G_MDSFT_ALPHADITHER, 2, mode);
}

/* 'blendmask' is not supported anymore.
 * The bits are reserved for future use.
 * Fri May 26 13:45:55 PDT 1995
 */
extern (D) auto gDPSetBlendMask(T0, T1)(auto ref T0 pkt, auto ref T1 mask)
{
    return gDPNoOp(pkt);
}

extern (D) auto gsDPSetBlendMask(T)(auto ref T mask)
{
    return gsDPNoOp();
}

extern (D) auto gDPSetAlphaCompare(T0, T1)(auto ref T0 pkt, auto ref T1 type)
{
    gSPSetOtherMode(pkt, G_SETOTHERMODE_L, G_MDSFT_ALPHACOMPARE, 2, type);
}

extern (D) auto gsDPSetAlphaCompare(T)(auto ref T type)
{
    return gsSPSetOtherMode(G_SETOTHERMODE_L, G_MDSFT_ALPHACOMPARE, 2, type);
}

extern (D) auto gDPSetDepthSource(T0, T1)(auto ref T0 pkt, auto ref T1 src)
{
    gSPSetOtherMode(pkt, G_SETOTHERMODE_L, G_MDSFT_ZSRCSEL, 1, src);
}

extern (D) auto gsDPSetDepthSource(T)(auto ref T src)
{
    return gsSPSetOtherMode(G_SETOTHERMODE_L, G_MDSFT_ZSRCSEL, 1, src);
}

extern (D) auto gDPSetColorImage(T0, T1, T2, T3, T4)(auto ref T0 pkt, auto ref T1 f, auto ref T2 s, auto ref T3 w, auto ref T4 i)
{
    return gSetImage(pkt, G_SETCIMG, f, s, w, i);
}

extern (D) auto gsDPSetColorImage(T0, T1, T2, T3)(auto ref T0 f, auto ref T1 s, auto ref T2 w, auto ref T3 i)
{
    return gsSetImage(G_SETCIMG, f, s, w, i);
}

/* use these for new code */
extern (D) auto gDPSetDepthImage(T0, T1)(auto ref T0 pkt, auto ref T1 i)
{
    return gSetImage(pkt, G_SETZIMG, 0, 0, 1, i);
}

extern (D) auto gsDPSetDepthImage(T)(auto ref T i)
{
    return gsSetImage(G_SETZIMG, 0, 0, 1, i);
}

/* kept for compatibility */
alias gDPSetMaskImage = gDPSetDepthImage;
alias gsDPSetMaskImage = gsDPSetDepthImage;

extern (D) auto gDPSetTextureImage(T0, T1, T2, T3, T4)(auto ref T0 pkt, auto ref T1 f, auto ref T2 s, auto ref T3 w, auto ref T4 i)
{
    return gSetImage(pkt, G_SETTIMG, f, s, w, i);
}

extern (D) auto gsDPSetTextureImage(T0, T1, T2, T3)(auto ref T0 f, auto ref T1 s, auto ref T2 w, auto ref T3 i)
{
    return gsSetImage(G_SETTIMG, f, s, w, i);
}

/*
 * RDP macros
 */

extern (D) auto GCCc0w0(T0, T1, T2, T3)(auto ref T0 saRGB0, auto ref T1 mRGB0, auto ref T2 saA0, auto ref T3 mA0)
{
    return _SHIFTL(saRGB0, 20, 4) | _SHIFTL(mRGB0, 15, 5) | _SHIFTL(saA0, 12, 3) | _SHIFTL(mA0, 9, 3);
}

extern (D) auto GCCc1w0(T0, T1)(auto ref T0 saRGB1, auto ref T1 mRGB1)
{
    return _SHIFTL(saRGB1, 5, 4) | _SHIFTL(mRGB1, 0, 5);
}

extern (D) auto GCCc0w1(T0, T1, T2, T3)(auto ref T0 sbRGB0, auto ref T1 aRGB0, auto ref T2 sbA0, auto ref T3 aA0)
{
    return _SHIFTL(sbRGB0, 28, 4) | _SHIFTL(aRGB0, 15, 3) | _SHIFTL(sbA0, 12, 3) | _SHIFTL(aA0, 9, 3);
}

extern (D) auto GCCc1w1(T0, T1, T2, T3, T4, T5)(auto ref T0 sbRGB1, auto ref T1 saA1, auto ref T2 mA1, auto ref T3 aRGB1, auto ref T4 sbA1, auto ref T5 aA1)
{
    return _SHIFTL(sbRGB1, 24, 4) | _SHIFTL(saA1, 21, 3) | _SHIFTL(mA1, 18, 3) | _SHIFTL(aRGB1, 6, 3) | _SHIFTL(sbA1, 3, 3) | _SHIFTL(aA1, 0, 3);
}

/*
 * SetCombineMode macros are NOT redunant. It allow the C preprocessor
 * to substitute single parameter which includes commas in the token and
 * rescan for higher parameter count macro substitution.
 *
 * eg.	gsDPSetCombineMode(G_CC_MODULATE, G_CC_MODULATE) turns into
 *	gsDPSetCombineLERP(TEXEL0, 0, SHADE, 0, TEXEL0, 0, SHADE, 0,
 *		TEXEL0, 0, SHADE, 0, TEXEL0, 0, SHADE, 0)
 */

//@@@ D conversion - todo: fix
//alias gDPSetCombineMode = gDPSetCombineLERP;
//alias gsDPSetCombineMode = gsDPSetCombineLERP;

extern (D) void gDPSetColor(T)(void* pkt, T c, T d)
{
    Gfx *_g = cast(Gfx*) pkt;

    _g.words.w0 = _SHIFTL(c, 24, 8);
    _g.words.w1 = cast(uint) d;
}

//extern (D) auto gsDPSetColor(T)(T c, T d)
//{
//    return _SHIFTL(c, 24, 8), (unsigned int)(d)
//}

extern (D) void DPRGBColor(T0, T1, T2, T3, T4, T5)(auto ref T0 pkt, auto ref T1 cmd, auto ref T2 r, auto ref T3 g, auto ref T4 b, auto ref T5 a)
{
    gDPSetColor(pkt, cmd, _SHIFTL(r, 24, 8) | _SHIFTL(g, 16, 8) | _SHIFTL(b, 8, 8) | _SHIFTL(a, 0, 8));
}

//extern (D) auto sDPRGBColor(T0, T1, T2, T3, T4)(auto ref T0 cmd, auto ref T1 r, auto ref T2 g, auto ref T3 b, auto ref T4 a)
//{
//    return gsDPSetColor(cmd, _SHIFTL(r, 24, 8) | _SHIFTL(g, 16, 8) | _SHIFTL(b, 8, 8) | _SHIFTL(a, 0, 8));
//}

extern (D) void gDPSetEnvColor(T0, T1, T2, T3, T4)(auto ref T0 pkt, auto ref T1 r, auto ref T2 g, auto ref T3 b, auto ref T4 a)
{
    DPRGBColor(pkt, G_SETENVCOLOR, r, g, b, a);
}

//extern (D) auto gsDPSetEnvColor(T0, T1, T2, T3)(auto ref T0 r, auto ref T1 g, auto ref T2 b, auto ref T3 a)
//{
//    return sDPRGBColor(G_SETENVCOLOR, r, g, b, a);
//}

//extern (D) auto gDPSetBlendColor(T0, T1, T2, T3, T4)(auto ref T0 pkt, auto ref T1 r, auto ref T2 g, auto ref T3 b, auto ref T4 a)
//{
//    return DPRGBColor(pkt, G_SETBLENDCOLOR, r, g, b, a);
//}

//extern (D) auto gsDPSetBlendColor(T0, T1, T2, T3)(auto ref T0 r, auto ref T1 g, auto ref T2 b, auto ref T3 a)
//{
//    return sDPRGBColor(G_SETBLENDCOLOR, r, g, b, a);
//}

//extern (D) auto gDPSetFogColor(T0, T1, T2, T3, T4)(auto ref T0 pkt, auto ref T1 r, auto ref T2 g, auto ref T3 b, auto ref T4 a)
//{
//    return DPRGBColor(pkt, G_SETFOGCOLOR, r, g, b, a);
//}

//extern (D) auto gsDPSetFogColor(T0, T1, T2, T3)(auto ref T0 r, auto ref T1 g, auto ref T2 b, auto ref T3 a)
//{
//    return sDPRGBColor(G_SETFOGCOLOR, r, g, b, a);
//}

extern (D) void gDPSetFillColor(T0, T1)(auto ref T0 pkt, auto ref T1 d)
{
    gDPSetColor(pkt, G_SETFILLCOLOR, d);
}

//extern (D) auto gsDPSetFillColor(T)(auto ref T d)
//{
//    return gsDPSetColor(G_SETFILLCOLOR, d);
//}

/*
 * gDPSetOtherMode (This is for expert user.)
 *
 * This command makes all othermode parameters set.
 * Do not use this command in the same DL with another g*SPSetOtherMode DLs.
 *
 * [Usage]
 *	gDPSetOtherMode(pkt, modeA, modeB)
 *
 *      'modeA' is described all parameters of GroupA GBI command.
 *      'modeB' is also described all parameters of GroupB GBI command.
 *
 *	GroupA:
 *	  gDPPipelineMode, gDPSetCycleType, gSPSetTexturePersp,
 *	  gDPSetTextureDetail, gDPSetTextureLOD, gDPSetTextureLUT,
 *	  gDPSetTextureFilter, gDPSetTextureConvert, gDPSetCombineKey,
 *	  gDPSetColorDither, gDPSetAlphaDither
 *
 *	GroupB:
 *	  gDPSetAlphaCompare, gDPSetDepthSource, gDPSetRenderMode
 *
 *	Use 'OR' operation to get modeA and modeB.
 *
 *	modeA = G_PM_* | G_CYC_* | G_TP_* | G_TD_* | G_TL_* | G_TT_* | G_TF_*
 *		G_TC_* | G_CK_*  | G_CD_* | G_AD_*;
 *
 *	modeB = G_AC_* | G_ZS_*  | G_RM_* | G_RM_*2;
 */

/*
 * Texturing macros
 */

/* These are also defined defined above for Sprite Microcode */

enum G_TX_LOADTILE = 7;
enum G_TX_RENDERTILE = 0;

enum G_TX_NOMIRROR = 0;
enum G_TX_WRAP = 0;
enum G_TX_MIRROR = 0x1;
enum G_TX_CLAMP = 0x2;
enum G_TX_NOMASK = 0;
enum G_TX_NOLOD = 0;

extern (D) auto MAX(T0, T1)(auto ref T0 a, auto ref T1 b)
{
    return a > b ? a : b;
}

extern (D) auto MIN(T0, T1)(auto ref T0 a, auto ref T1 b)
{
    return a < b ? a : b;
}

/*
 *  Dxt is the inverse of the number of 64-bit words in a line of
 *  the texture being loaded using the load_block command.  If
 *  there are any 1's to the right of the 11th fractional bit,
 *  dxt should be rounded up.  The following macros accomplish
 *  this.  The 4b macros are a special case since 4-bit textures
 *  are loaded as 8-bit textures.  Dxt is fixed point 1.11. RJM
 */
enum G_TX_DXT_FRAC = 11;

/*
 *  For RCP 2.0, the maximum number of texels that can be loaded
 *  using a load_block command is 2048.  In order to load the total
 *  4kB of Tmem, change the texel size when loading to be G_IM_SIZ_16b,
 *  then change the tile to the proper texel size after the load.
 *  The g*DPLoadTextureBlock macros already do this, so this change
 *  will be transparent if you use these macros.  If you use
 *  the g*DPLoadBlock macros directly, you will need to handle this
 *  tile manipulation yourself.  RJM.
 */

enum G_TX_LDBLK_MAX_TXL = 2047;
/* _HW_VERSION_1 */

extern (D) auto TXL2WORDS(T0, T1)(auto ref T0 txls, auto ref T1 b_txl)
{
    return MAX(1, txls * b_txl / 8);
}

extern (D) auto CALC_DXT(T0, T1)(auto ref T0 width, auto ref T1 b_txl)
{
    return ((1 << G_TX_DXT_FRAC) + TXL2WORDS(width, b_txl) - 1) / TXL2WORDS(width, b_txl);
}

extern (D) auto TXL2WORDS_4b(T)(auto ref T txls)
{
    return MAX(1, txls / 16);
}

extern (D) auto CALC_DXT_4b(T)(auto ref T width)
{
    return ((1 << G_TX_DXT_FRAC) + TXL2WORDS_4b(width) - 1) / TXL2WORDS_4b(width);
}

extern (D) auto gDPSetTileSize(T0, T1, T2, T3, T4, T5)(auto ref T0 pkt, auto ref T1 t, auto ref T2 uls, auto ref T3 ult, auto ref T4 lrs, auto ref T5 lrt)
{
    return gDPLoadTileGeneric(pkt, G_SETTILESIZE, t, uls, ult, lrs, lrt);
}

extern (D) auto gsDPSetTileSize(T0, T1, T2, T3, T4)(auto ref T0 t, auto ref T1 uls, auto ref T2 ult, auto ref T3 lrs, auto ref T4 lrt)
{
    return gsDPLoadTileGeneric(G_SETTILESIZE, t, uls, ult, lrs, lrt);
}

extern (D) auto gDPLoadTile(T0, T1, T2, T3, T4, T5)(auto ref T0 pkt, auto ref T1 t, auto ref T2 uls, auto ref T3 ult, auto ref T4 lrs, auto ref T5 lrt)
{
    return gDPLoadTileGeneric(pkt, G_LOADTILE, t, uls, ult, lrs, lrt);
}

extern (D) auto gsDPLoadTile(T0, T1, T2, T3, T4)(auto ref T0 t, auto ref T1 uls, auto ref T2 ult, auto ref T3 lrs, auto ref T4 lrt)
{
    return gsDPLoadTileGeneric(G_LOADTILE, t, uls, ult, lrs, lrt);
}

/*
 *  For RCP 2.0, the maximum number of texels that can be loaded
 *  using a load_block command is 2048.  In order to load the total
 *  4kB of Tmem, change the texel size when loading to be G_IM_SIZ_16b,
 *  then change the tile to the proper texel size after the load.
 *  The g*DPLoadTextureBlock macros already do this, so this change
 *  will be transparent if you use these macros.  If you use
 *  the g*DPLoadBlock macros directly, you will need to handle this
 *  tile manipulation yourself.  RJM.
 */

/* Load fix rww 27jun95 */
/* The S at the end means odd lines are already word Swapped */

/*
 *  Allow tmem address and render tile to be specified.
 *  The S at the end means odd lines are already word Swapped
 */

/*
 *  allows tmem address to be specified
 */

/*
 *  allows tmem address and render tile to be specified
 */

/*
 *  allows tmem address and render tile to be specified
 */

/* Here is the static form of the pre-swapped texture block loading */
/* See gDPLoadTextureBlockS() for reference.  Basically, just don't
   calculate DxT, use 0 */

/*
 *  Allow tmem address to be specified
 */

/*
 *  Allow tmem address and render_tile to be specified
 */

/*
 *  Allow tmem address and render_tile to be specified, useful when loading
 *  mutilple tiles at a time.
 */

/*
 *  Allows tmem and render tile to be specified.  Useful when loading
 *  several tiles at a time.
 *
 *  Here is the static form of the pre-swapped texture block loading
 *  See gDPLoadTextureBlockS() for reference.  Basically, just don't
 *  calculate DxT, use 0
 */

/* Load fix rww 27jun95 */
/* The S at the end means odd lines are already word Swapped */

/*
 *  4-bit load block.  Useful when loading multiple tiles
 */

/*
 *  4-bit load block.  Allows tmem and render tile to be specified.  Useful when
 *  loading multiple tiles.  The S means odd lines are already word swapped.
 */

/*
 *  4-bit load block.  Allows tmem address and render tile to be specified.
 *  Useful when loading multiple tiles.
 */

/*
 *  4-bit load block.  Allows tmem address and render tile to be specified.
 *  Useful when loading multiple tiles.  S means odd lines are already swapped.
 */

/*
 *  Allows tmem address to be specified
 */

/******** WORKAROUND hw 1 load tile bug ********/

/* HW_VERSION_1 */

/*
 *  Load texture tile.  Allows tmem address and render tile to be specified.
 *  Useful for loading multiple tiles.
 */

/*
 *  Load texture tile.  Allows tmem address and render tile to be specified.
 *  Useful for loading multiple tiles.
 */

/*
 *  Load texture tile.  Allows tmem address and render tile to be specified.
 *  Useful for loading multiple tiles.
 */

/*
 *  Load texture tile.  Allows tmem address and render tile to be specified.
 *  Useful for loading multiple tiles.
 */

/*
 *  Load a 16-entry palette (for 4-bit CI textures)
 *  Assumes a 16 entry tlut is being loaded, palette # is 0-15
 */

/* **** WORKAROUND hardware 1 load_tlut bug ****** */

/* _HW_VERSION_1 */

/*
 *  Load a 16-entry palette (for 4-bit CI textures)
 *  Assumes a 16 entry tlut is being loaded, palette # is 0-15
 */

/* **** WORKAROUND hardware 1 load_tlut bug ****** */

/* _HW_VERSION_1 */

/*
 *  Load a 256-entry palette (for 8-bit CI textures)
 *  Assumes a 256 entry tlut is being loaded, palette # is not used
 */

/* **** WORKAROUND hardware 1 load_tlut bug ****** */

/* _HW_VERSION_1 */

/* **** WORKAROUND hardware 1 load_tlut bug ****** */

/* _HW_VERSION_1 */

/* **** WORKAROUND hardware 1 load_tlut bug ****** */

/* _HW_VERSION_1 */

/* **** WORKAROUND hardware 1 load_tlut bug ****** */

/* _HW_VERSION_1 */

/* Fraction never used in fill */

/* like gDPFillRectangle but accepts negative arguments */

/* Notice that textured rectangles are 128-bit commands, therefore
 * gsDPTextureRectangle() should not be used in display lists
 * under normal circumstances (use gsSPTextureRectangle()).
 * That is also why there is no gDPTextureRectangle() macros.
 */

/* like gSPTextureRectangle but accepts negative position arguments */

/* like gSPTextureRectangle but accepts negative position arguments */

//@@@ D conversion - todo: fix
//extern (D) auto gDPFullSync(T)(auto ref T pkt)
//{
//    return gDPNoParam(pkt, G_RDPFULLSYNC);
//}

//extern (D) auto gsDPFullSync()
//{
//    return gsDPNoParam(G_RDPFULLSYNC);
//}

//extern (D) auto gDPTileSync(T)(auto ref T pkt)
//{
//    return gDPNoParam(pkt, G_RDPTILESYNC);
//}

//extern (D) auto gsDPTileSync()
//{
//    return gsDPNoParam(G_RDPTILESYNC);
//}

//extern (D) auto gDPPipeSync(T)(auto ref T pkt)
//{
//    return gDPNoParam(pkt, G_RDPPIPESYNC);
//}

//extern (D) auto gsDPPipeSync()
//{
//    return gsDPNoParam(G_RDPPIPESYNC);
//}

//extern (D) auto gDPLoadSync(T)(auto ref T pkt)
//{
//    return gDPNoParam(pkt, G_RDPLOADSYNC);
//}

//extern (D) auto gsDPLoadSync()
//{
//    return gsDPNoParam(G_RDPLOADSYNC);
//}

//extern (D) auto gDPNoOp(T)(auto ref T pkt)
//{
//    return gDPNoParam(pkt, G_NOOP);
//}

//extern (D) auto gsDPNoOp()
//{
//    return gsDPNoParam(G_NOOP);
//}

//extern (D) auto gDPNoOpTag(T0, T1)(auto ref T0 pkt, auto ref T1 tag)
//{
//    return gDPParam(pkt, G_NOOP, tag);
//}

//extern (D) auto gsDPNoOpTag(T)(auto ref T tag)
//{
//    return gsDPParam(G_NOOP, tag);
//}

// #endif /* _LANGUAGE_C */

/* _GBI_H_ */
